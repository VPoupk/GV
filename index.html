<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Bouncing Ball - Catch Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    canvas { display: block; cursor: crosshair; }

    #hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 10;
      pointer-events: none;
    }
    .hud-item {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 10px 20px;
      color: #fff;
      text-align: center;
    }
    .hud-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 2px;
    }
    .hud-value {
      font-size: 28px;
      font-weight: 700;
    }
    #score-value { color: #4fc3f7; }
    #streak-value { color: #ffb74d; }
    #time-value { color: #80cbc4; }
    #bonus-value { color: #66bb6a; transition: color 0.3s; }
    #bonus-value.low { color: #ef5350; }

    #message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 22px;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      z-index: 10;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
      transition: opacity 0.3s;
    }

    .overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      color: #fff;
    }
    .overlay h1 {
      font-size: 48px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #4fc3f7, #ce93d8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .overlay p {
      font-size: 18px;
      color: rgba(255,255,255,0.6);
      margin-bottom: 30px;
    }
    .overlay-btn {
      padding: 14px 40px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 30px;
      background: linear-gradient(135deg, #4fc3f7, #7c4dff);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin: 6px;
    }
    .overlay-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(79, 195, 247, 0.4);
    }
    .overlay-btn.secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .overlay-btn.secondary:hover {
      background: rgba(255,255,255,0.18);
      box-shadow: none;
    }

    #name-input {
      padding: 12px 20px;
      font-size: 18px;
      font-weight: 600;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      background: rgba(255,255,255,0.08);
      color: #fff;
      text-align: center;
      outline: none;
      width: 220px;
      margin-bottom: 20px;
      transition: border-color 0.2s;
    }
    #name-input::placeholder { color: rgba(255,255,255,0.3); }
    #name-input:focus { border-color: rgba(79,195,247,0.6); }

    #end-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 15;
      padding: 8px 20px;
      font-size: 14px;
      font-weight: 600;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 20px;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(8px);
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      display: none;
    }
    #end-btn:hover { background: rgba(239,83,80,0.4); color: #fff; }

    /* Screens - hidden by default (shown via JS) */
    #name-screen { display: none; }
    #leaderboard { display: none; }
    #leaderboard h1 { margin-bottom: 6px; }
    .lb-session-summary {
      margin-bottom: 24px;
      text-align: center;
      line-height: 1.8;
    }
    .lb-session-summary span {
      display: inline-block;
      background: rgba(255,255,255,0.08);
      border-radius: 8px;
      padding: 4px 14px;
      margin: 0 6px;
      font-weight: 600;
    }
    .lb-columns {
      display: flex;
      gap: 24px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .lb-col {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      padding: 18px 22px;
      min-width: 200px;
      text-align: center;
    }
    .lb-col h3 {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255,255,255,0.5);
      margin-bottom: 12px;
    }
    .lb-col ol {
      list-style: none;
      padding: 0;
    }
    .lb-col li {
      padding: 6px 0;
      font-size: 16px;
      font-weight: 600;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex;
      justify-content: space-between;
      gap: 16px;
    }
    .lb-col li:last-child { border-bottom: none; }
    .lb-rank { color: rgba(255,255,255,0.35); font-size: 13px; }
    .lb-val { color: #4fc3f7; }
    .lb-col.streak .lb-val { color: #ffb74d; }
    .lb-col.session .lb-val { color: #80cbc4; }
    .lb-name { color: rgba(255,255,255,0.7); font-size: 14px; flex: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .lb-new { color: #66bb6a; font-size: 11px; margin-left: 6px; }
  </style>
</head>
<body>
  <div id="start-screen" class="overlay">
    <h1>Bouncing Ball</h1>
    <p>Catch the ball fast! Smaller ball = more points, quicker catch = higher bonus</p>
    <div>
      <button id="start-btn" class="overlay-btn">Play</button>
      <button id="start-lb-btn" class="overlay-btn secondary">Leaderboard</button>
    </div>
  </div>

  <div id="name-screen" class="overlay">
    <h1>Enter Your Name</h1>
    <p>Choose a name before you start playing</p>
    <input id="name-input" type="text" placeholder="Your name" maxlength="16" autocomplete="off" spellcheck="false">
    <div id="name-error" style="color:#ef5350;font-size:14px;margin-bottom:12px;min-height:20px;"></div>
    <div>
      <button id="name-go-btn" class="overlay-btn">Start</button>
      <button id="name-cancel-btn" class="overlay-btn secondary">Back</button>
    </div>
  </div>

  <div id="leaderboard" class="overlay">
    <h1>Leaderboard</h1>
    <div class="lb-session-summary" id="lb-session-summary"></div>
    <div class="lb-columns" id="lb-columns"></div>
    <div>
      <button id="lb-play-btn" class="overlay-btn">Play Again</button>
      <button id="lb-back-btn" class="overlay-btn secondary">Main Menu</button>
    </div>
  </div>

  <button id="end-btn">End Session</button>

  <div id="hud">
    <div class="hud-item">
      <div class="hud-label">Score</div>
      <div class="hud-value" id="score-value">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Streak</div>
      <div class="hud-value" id="streak-value">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Time</div>
      <div class="hud-value" id="time-value">0:00</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Bonus</div>
      <div class="hud-value" id="bonus-value">--</div>
    </div>
  </div>

  <div id="message"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ── Game State ──────────────────────────────────────────────
    const state = {
      score: 0,
      streak: 0,
      bestStreak: 0,
      missStreak: 0,         // consecutive misses — grows ball every 5
      running: false,
      sessionStart: 0,       // clock.elapsedTime when Play was pressed
      sessionTime: 0,        // seconds of current session
      sessionStartWall: 0,   // Date.now() when Play was pressed (for crash recovery)
      playerName: '',
    };

    // ── Name persistence ──────────────────────────────────────
    const NAME_KEY = 'bouncingBall_playerName';
    const nameInput = document.getElementById('name-input');
    nameInput.value = localStorage.getItem(NAME_KEY) || '';

    // ── Leaderboard (localStorage) ────────────────────────────
    const LB_KEY = 'bouncingBall_leaderboard';
    const LIVE_KEY = 'bouncingBall_liveSession';
    const LB_MAX = 5;

    function loadLeaderboard() {
      try { return JSON.parse(localStorage.getItem(LB_KEY)) || { score: [], streak: [], session: [] }; }
      catch { return { score: [], streak: [], session: [] }; }
    }

    function saveLeaderboard(lb) {
      localStorage.setItem(LB_KEY, JSON.stringify(lb));
    }

    // Returns { score: idx|null, streak: idx|null, session: idx|null } for new entries
    function recordSession(name, score, bestStreak, sessionSecs) {
      const lb = loadLeaderboard();
      const newFlags = { score: null, streak: null, session: null };

      function insert(list, value) {
        const entry = { value, name: name || 'Anonymous', date: Date.now() };
        let idx = list.findIndex(e => value > e.value);
        if (idx === -1) idx = list.length;
        if (idx >= LB_MAX) return null;
        list.splice(idx, 0, entry);
        if (list.length > LB_MAX) list.pop();
        return idx;
      }

      if (score > 0) newFlags.score = insert(lb.score, score);
      if (bestStreak > 0) newFlags.streak = insert(lb.streak, bestStreak);
      if (sessionSecs > 0) newFlags.session = insert(lb.session, Math.round(sessionSecs));

      saveLeaderboard(lb);
      return newFlags;
    }

    // ── Live Session Persistence (crash/tab-close recovery) ───
    function saveLiveSession() {
      if (!state.running) return;
      const elapsed = (Date.now() - state.sessionStartWall) / 1000;
      localStorage.setItem(LIVE_KEY, JSON.stringify({
        name: state.playerName,
        score: state.score,
        bestStreak: state.bestStreak,
        startWall: state.sessionStartWall,
        elapsed,
      }));
    }

    function clearLiveSession() {
      localStorage.removeItem(LIVE_KEY);
    }

    function recoverCrashedSession() {
      try {
        const raw = localStorage.getItem(LIVE_KEY);
        if (!raw) return;
        const s = JSON.parse(raw);
        // Calculate total session time using wall-clock timestamps
        const totalSecs = (Date.now() - s.startWall) / 1000;
        // Only recover sessions that are at least 2 seconds and not absurdly old (>24h)
        if (totalSecs < 2 || totalSecs > 86400) { clearLiveSession(); return; }
        recordSession(s.name, s.score, s.bestStreak, totalSecs);
        clearLiveSession();
      } catch { clearLiveSession(); }
    }

    // Recover any orphaned session from a previous crash/tab close
    recoverCrashedSession();

    function formatTime(secs) {
      const s = Math.round(secs);
      const m = Math.floor(s / 60);
      const sec = s % 60;
      return `${m}:${sec.toString().padStart(2, '0')}`;
    }

    function escapeHtml(str) {
      return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }

    function renderLeaderboard(newFlags, sessionScore, sessionStreak, sessionSecs) {
      const lb = loadLeaderboard();
      const summaryEl = document.getElementById('lb-session-summary');
      const colsEl = document.getElementById('lb-columns');

      // Session summary (only shown if we just ended a session)
      if (sessionScore != null) {
        summaryEl.innerHTML =
          `<span style="color:#4fc3f7">Score: ${sessionScore}</span>` +
          `<span style="color:#ffb74d">Best Streak: ${sessionStreak}</span>` +
          `<span style="color:#80cbc4">Time: ${formatTime(sessionSecs)}</span>`;
        summaryEl.style.display = '';
      } else {
        summaryEl.style.display = 'none';
      }

      const categories = [
        { key: 'score', title: 'Highest Score', cls: 'score', fmt: v => v.toLocaleString() },
        { key: 'streak', title: 'Best Streak', cls: 'streak', fmt: v => v },
        { key: 'session', title: 'Longest Session', cls: 'session', fmt: v => formatTime(v) },
      ];

      colsEl.innerHTML = categories.map(cat => {
        const rows = lb[cat.key].length > 0
          ? lb[cat.key].map((e, i) => {
              const isNew = newFlags && newFlags[cat.key] === i;
              const name = escapeHtml(e.name || 'Anonymous');
              return `<li><span class="lb-rank">#${i + 1}</span><span class="lb-name">${name}</span> <span class="lb-val">${cat.fmt(e.value)}${isNew ? '<span class="lb-new">NEW</span>' : ''}</span></li>`;
            }).join('')
          : '<li style="color:rgba(255,255,255,0.3)">No records yet</li>';
        return `<div class="lb-col ${cat.cls}"><h3>${cat.title}</h3><ol>${rows}</ol></div>`;
      }).join('');
    }

    // ── Room Dimensions ─────────────────────────────────────────
    const ROOM = { w: 10, h: 7, d: 10 };
    const BALL_BASE_RADIUS = 0.4;
    const BALL_MIN_RADIUS = 0.25;
    const BALL_MAX_RADIUS = 0.7;
    let currentBallRadius = BALL_BASE_RADIUS;

    // Scoring coefficients
    const SIZE_COEFF = 3.0;   // at smallest ball: 4x multiplier; at largest: 1x
    const TIME_COEFF = 0.1;   // lose 0.1x per second elapsed
    const TIME_MIN_MULT = 0.1; // time multiplier floor
    const MERCY_GROW_STEP = 0.15; // how much radius grows per 5 misses
    let ballSpawnTime = 0;     // timestamp when current ball appeared

    // ── Scene Setup ─────────────────────────────────────────────
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x1a1a2e, 0.035);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 2, ROOM.d / 2 + 4);
    camera.lookAt(0, 1, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // ── Lighting ────────────────────────────────────────────────
    const ambientLight = new THREE.AmbientLight(0x404060, 0.8);
    scene.add(ambientLight);

    const mainLight = new THREE.PointLight(0xffffff, 60, 30);
    mainLight.position.set(0, ROOM.h - 1, 0);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(1024, 1024);
    scene.add(mainLight);

    // Light fixture visual
    const bulbGeo = new THREE.SphereGeometry(0.2, 16, 16);
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
    const bulb = new THREE.Mesh(bulbGeo, bulbMat);
    bulb.position.copy(mainLight.position);
    scene.add(bulb);

    const accentLight1 = new THREE.PointLight(0x4fc3f7, 15, 15);
    accentLight1.position.set(-ROOM.w / 2 + 1, 1, -ROOM.d / 2 + 1);
    scene.add(accentLight1);

    const accentLight2 = new THREE.PointLight(0xce93d8, 15, 15);
    accentLight2.position.set(ROOM.w / 2 - 1, 1, ROOM.d / 2 - 1);
    scene.add(accentLight2);

    // ── Room Construction ───────────────────────────────────────
    const wallMat = new THREE.MeshStandardMaterial({
      color: 0x2c2c3e,
      roughness: 0.85,
      metalness: 0.05,
    });

    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x3a3a4e,
      roughness: 0.6,
      metalness: 0.1,
    });

    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Ceiling
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), wallMat);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = ROOM.h;
    scene.add(ceiling);

    // Back wall
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.h), wallMat);
    backWall.position.set(0, ROOM.h / 2, -ROOM.d / 2);
    backWall.receiveShadow = true;
    scene.add(backWall);

    // Front wall (transparent so we can see in)
    // Left wall
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.d, ROOM.h), wallMat);
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.set(-ROOM.w / 2, ROOM.h / 2, 0);
    leftWall.receiveShadow = true;
    scene.add(leftWall);

    // Right wall
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.d, ROOM.h), wallMat);
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.set(ROOM.w / 2, ROOM.h / 2, 0);
    rightWall.receiveShadow = true;
    scene.add(rightWall);

    // ── Decorative Edge Lines ───────────────────────────────────
    const edgeMat = new THREE.LineBasicMaterial({ color: 0x5a5a7a, transparent: true, opacity: 0.4 });
    function addEdge(points) {
      const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(...p)));
      scene.add(new THREE.Line(geo, edgeMat));
    }
    const hw = ROOM.w / 2, hd = ROOM.d / 2, h = ROOM.h;
    // Floor edges
    addEdge([[-hw, 0, -hd], [hw, 0, -hd]]);
    addEdge([[-hw, 0, -hd], [-hw, 0, hd]]);
    addEdge([[hw, 0, -hd], [hw, 0, hd]]);
    // Ceiling edges
    addEdge([[-hw, h, -hd], [hw, h, -hd]]);
    addEdge([[-hw, h, -hd], [-hw, h, hd]]);
    addEdge([[hw, h, -hd], [hw, h, hd]]);
    // Vertical edges
    addEdge([[-hw, 0, -hd], [-hw, h, -hd]]);
    addEdge([[hw, 0, -hd], [hw, h, -hd]]);

    // ── Ball ────────────────────────────────────────────────────
    const ballGeo = new THREE.SphereGeometry(1, 32, 32); // unit sphere, scaled dynamically
    const ballMat = new THREE.MeshStandardMaterial({
      color: 0xff5252,
      roughness: 0.2,
      metalness: 0.6,
      emissive: 0xff5252,
      emissiveIntensity: 0.15,
    });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    ball.castShadow = true;
    ball.scale.setScalar(currentBallRadius);
    scene.add(ball);

    // Ball glow
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0xff5252,
      transparent: true,
      opacity: 0.12,
    });
    const glow = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), glowMat);
    ball.add(glow);

    // Randomize ball size and update visuals
    function randomizeBallSize() {
      currentBallRadius = BALL_MIN_RADIUS + Math.random() * (BALL_MAX_RADIUS - BALL_MIN_RADIUS);
      ball.scale.setScalar(currentBallRadius);
    }

    // Ball shadow blob on floor
    const shadowBlobGeo = new THREE.PlaneGeometry(1.2, 1.2);
    const shadowBlobMat = new THREE.MeshBasicMaterial({
      color: 0x000000,
      transparent: true,
      opacity: 0.3,
      depthWrite: false,
    });
    const shadowBlob = new THREE.Mesh(shadowBlobGeo, shadowBlobMat);
    shadowBlob.rotation.x = -Math.PI / 2;
    shadowBlob.position.y = 0.01;
    scene.add(shadowBlob);

    // ── Ball Physics ────────────────────────────────────────────
    const ballPos = new THREE.Vector3(0, ROOM.h / 2, 0);
    const ballVel = new THREE.Vector3(
      (Math.random() - 0.5) * 6,
      (Math.random() - 0.5) * 4,
      (Math.random() - 0.5) * 6
    );
    const gravity = -10;
    const restitution = 0.82;
    const airDrag = 0.995;
    const minBounceVel = 1.5;

    // ── Particles ───────────────────────────────────────────────
    const MAX_PARTICLES = 800;
    const particlePositions = new Float32Array(MAX_PARTICLES * 3);
    const particleColors = new Float32Array(MAX_PARTICLES * 3);
    const particleSizes = new Float32Array(MAX_PARTICLES);
    const particleGeo = new THREE.BufferGeometry();
    particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

    const particleMat = new THREE.PointsMaterial({
      size: 0.12,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      depthWrite: false,
    });
    const particleSystem = new THREE.Points(particleGeo, particleMat);
    scene.add(particleSystem);

    const particles = [];

    function spawnParticles(pos, color, count) {
      const c = new THREE.Color(color);
      for (let i = 0; i < count; i++) {
        particles.push({
          pos: pos.clone(),
          vel: new THREE.Vector3(
            (Math.random() - 0.5) * 8,
            Math.random() * 6 + 2,
            (Math.random() - 0.5) * 8
          ),
          color: c,
          life: 1.0,
          decay: 0.6 + Math.random() * 0.8,
        });
      }
      // Cap total
      while (particles.length > MAX_PARTICLES) particles.shift();
    }

    // ── Streak Explosion Effects ──────────────────────────────
    // Tier 1 (streak 1-2):  Simple pop — small cyan burst
    // Tier 2 (streak 3-4):  Sparkle burst — multi-color spread
    // Tier 3 (streak 5-7):  FIRE — rising flames + embers
    // Tier 4 (streak 8-11): ICE — frost shards + crystalline shimmer
    // Tier 5 (streak 12-16): ELECTRIC — lightning bolts + spark swarm
    // Tier 6 (streak 17-21): WIND — spiraling tornado + leaves
    // Tier 7 (streak 22+):  ELEMENTAL STORM — all four combined

    function streakExplosion(pos, streak) {
      if (streak >= 22) {
        // ── TIER 7: ELEMENTAL STORM ──
        // All four elements erupt together in a massive combined blast
        // Fire core
        for (let i = 0; i < 30; i++) {
          const theta = Math.random() * Math.PI * 2;
          const speed = 3 + Math.random() * 3;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(Math.cos(theta) * speed, 4 + Math.random() * 6, Math.sin(theta) * speed),
            color: new THREE.Color(1, 0.6, 0.1),
            life: 1.0, decay: 0.35 + Math.random() * 0.25,
            behavior: 'fire', seed: Math.random() * 100, age: 0,
          });
        }
        // Ice ring
        for (let i = 0; i < 30; i++) {
          const angle = (i / 30) * Math.PI * 2;
          const speed = 5 + Math.random() * 3;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(Math.cos(angle) * speed, (Math.random() - 0.3) * 4, Math.sin(angle) * speed),
            color: new THREE.Color(0.6, 0.85, 1),
            life: 1.0, decay: 0.3 + Math.random() * 0.2,
            behavior: 'ice', seed: Math.random() * 100, age: 0,
          });
        }
        // Electric bolts
        for (let i = 0; i < 30; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const speed = 6 + Math.random() * 5;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              Math.sin(phi) * Math.cos(theta) * speed,
              Math.sin(phi) * Math.sin(theta) * speed,
              Math.cos(phi) * speed
            ),
            color: new THREE.Color(0.5, 0.6, 1),
            life: 1.0, decay: 0.5 + Math.random() * 0.4,
            behavior: 'electric', seed: Math.random() * 100, age: 0,
          });
        }
        // Wind spiral
        for (let i = 0; i < 30; i++) {
          const angle = (i / 30) * Math.PI * 4;
          const r = 2 + Math.random() * 3;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(Math.cos(angle) * r, 3 + Math.random() * 4, Math.sin(angle) * r),
            color: new THREE.Color(0.7, 1, 0.8),
            life: 1.0, decay: 0.25 + Math.random() * 0.2,
            behavior: 'wind', seed: Math.random() * 100, age: 0,
          });
        }
        // White flash core
        for (let i = 0; i < 20; i++) {
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3((Math.random() - 0.5) * 2, Math.random() * 3, (Math.random() - 0.5) * 2),
            color: new THREE.Color(1, 1, 1),
            life: 1.0, decay: 1.2 + Math.random() * 0.5,
            behavior: 'default', age: 0,
          });
        }

      } else if (streak >= 17) {
        // ── TIER 6: WIND TORNADO ──
        // Spiraling vortex of green-cyan wind particles + floating leaves
        const count = 60;
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 6; // 3 full spirals
          const r = 2 + (i / count) * 4;
          const height = (i / count) * 8;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              Math.cos(angle) * r,
              height + Math.random() * 2,
              Math.sin(angle) * r
            ),
            color: new THREE.Color(0.7, 1, 0.85),
            life: 1.0, decay: 0.25 + Math.random() * 0.2,
            behavior: 'wind', seed: Math.random() * 100, age: 0,
          });
        }
        // Floating leaves
        for (let i = 0; i < 20; i++) {
          const c = new THREE.Color().setHSL(0.25 + Math.random() * 0.15, 0.7, 0.45);
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              (Math.random() - 0.5) * 6,
              2 + Math.random() * 5,
              (Math.random() - 0.5) * 6
            ),
            color: c,
            life: 1.0, decay: 0.2 + Math.random() * 0.25,
            behavior: 'leaf', seed: Math.random() * 100, age: 0,
          });
        }
        // Dust wisps at the base
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(Math.cos(angle) * 5, Math.random() * 1, Math.sin(angle) * 5),
            color: new THREE.Color(0.8, 0.9, 0.8),
            life: 1.0, decay: 0.5 + Math.random() * 0.3,
            behavior: 'wind', seed: Math.random() * 100, age: 0,
          });
        }

      } else if (streak >= 12) {
        // ── TIER 5: ELECTRIC STORM ──
        // Erratic lightning bolts + buzzing spark cloud
        // Main bolt branches — jagged outward lines
        for (let i = 0; i < 8; i++) {
          const baseAngle = (i / 8) * Math.PI * 2;
          const segments = 6;
          let bx = pos.x, by = pos.y, bz = pos.z;
          for (let s = 0; s < segments; s++) {
            const speed = 3 + Math.random() * 4;
            const jitterX = (Math.random() - 0.5) * 4;
            const jitterY = (Math.random() - 0.5) * 6;
            const jitterZ = (Math.random() - 0.5) * 4;
            particles.push({
              pos: new THREE.Vector3(bx, by, bz),
              vel: new THREE.Vector3(
                Math.cos(baseAngle) * speed + jitterX,
                jitterY + 2,
                Math.sin(baseAngle) * speed + jitterZ
              ),
              color: new THREE.Color(0.6, 0.8, 1),
              life: 1.0, decay: 0.7 + Math.random() * 0.5,
              behavior: 'bolt', seed: Math.random() * 100, age: 0,
            });
            bx += Math.cos(baseAngle) * 0.3 + (Math.random() - 0.5) * 0.5;
            by += (Math.random() - 0.5) * 0.4;
            bz += Math.sin(baseAngle) * 0.3 + (Math.random() - 0.5) * 0.5;
          }
        }
        // Spark swarm — chaotic buzzing particles
        for (let i = 0; i < 50; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const speed = 4 + Math.random() * 5;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              Math.sin(phi) * Math.cos(theta) * speed,
              Math.sin(phi) * Math.sin(theta) * speed,
              Math.cos(phi) * speed
            ),
            color: new THREE.Color(0.5, 0.6, 1),
            life: 1.0, decay: 0.45 + Math.random() * 0.35,
            behavior: 'electric', seed: Math.random() * 100, age: 0,
          });
        }
        // Bright white core flash
        for (let i = 0; i < 10; i++) {
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3((Math.random() - 0.5) * 2, Math.random() * 2, (Math.random() - 0.5) * 2),
            color: new THREE.Color(1, 1, 1),
            life: 1.0, decay: 1.5 + Math.random() * 0.5,
            behavior: 'bolt', seed: Math.random() * 100, age: 0,
          });
        }

      } else if (streak >= 8) {
        // ── TIER 4: ICE SHATTER ──
        // Expanding frost ring + crystalline shimmer + icicle shards
        // Frost ring expanding outward
        const ringCount = 40;
        for (let i = 0; i < ringCount; i++) {
          const angle = (i / ringCount) * Math.PI * 2;
          const speed = 5 + Math.random() * 3;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              Math.cos(angle) * speed,
              (Math.random() - 0.3) * 3,
              Math.sin(angle) * speed
            ),
            color: new THREE.Color(0.6, 0.85, 1),
            life: 1.0, decay: 0.3 + Math.random() * 0.25,
            behavior: 'ice', seed: Math.random() * 100, age: 0,
          });
        }
        // Icicle shards — fast upward/downward spikes
        for (let i = 0; i < 16; i++) {
          const angle = (i / 16) * Math.PI * 2;
          const up = i % 2 === 0 ? 1 : -1;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              Math.cos(angle) * 2,
              up * (5 + Math.random() * 4),
              Math.sin(angle) * 2
            ),
            color: new THREE.Color(0.8, 0.95, 1),
            life: 1.0, decay: 0.4 + Math.random() * 0.3,
            behavior: 'frost', seed: Math.random() * 100, age: 0,
          });
        }
        // Floating crystal dust
        for (let i = 0; i < 20; i++) {
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              (Math.random() - 0.5) * 4,
              Math.random() * 3 + 1,
              (Math.random() - 0.5) * 4
            ),
            color: new THREE.Color(0.9, 0.95, 1),
            life: 1.0, decay: 0.2 + Math.random() * 0.2,
            behavior: 'ice', seed: Math.random() * 100, age: 0,
          });
        }

      } else if (streak >= 5) {
        // ── TIER 3: FIRE BURST ──
        // Rising flame column + expanding ember ring + smoke wisps
        // Flame column — particles that rise and flicker
        const flameCount = 45;
        for (let i = 0; i < flameCount; i++) {
          const spread = Math.random() * 2;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              (Math.random() - 0.5) * spread * 3,
              3 + Math.random() * 8,
              (Math.random() - 0.5) * spread * 3
            ),
            color: new THREE.Color(1, 0.6, 0.1),
            life: 1.0, decay: 0.35 + Math.random() * 0.3,
            behavior: 'fire', seed: Math.random() * 100, age: 0,
          });
        }
        // Ember ring — expanding outward near floor
        for (let i = 0; i < 24; i++) {
          const angle = (i / 24) * Math.PI * 2;
          const speed = 4 + Math.random() * 2;
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              Math.cos(angle) * speed,
              0.5 + Math.random() * 2,
              Math.sin(angle) * speed
            ),
            color: new THREE.Color(1, 0.3, 0.05),
            life: 1.0, decay: 0.3 + Math.random() * 0.3,
            behavior: 'ember', seed: Math.random() * 100, age: 0,
          });
        }
        // Hot core flash
        for (let i = 0; i < 10; i++) {
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              (Math.random() - 0.5) * 1.5,
              Math.random() * 2,
              (Math.random() - 0.5) * 1.5
            ),
            color: new THREE.Color(1, 1, 0.7),
            life: 1.0, decay: 1.0 + Math.random() * 0.5,
            behavior: 'fire', seed: Math.random() * 100, age: 0,
          });
        }

      } else if (streak >= 3) {
        // ── TIER 2: SPARKLE BURST ──
        // Multi-color with wider spread
        const count = 40;
        for (let i = 0; i < count; i++) {
          const c = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
          particles.push({
            pos: pos.clone(),
            vel: new THREE.Vector3(
              (Math.random() - 0.5) * 10,
              Math.random() * 7 + 1,
              (Math.random() - 0.5) * 10
            ),
            color: c,
            life: 1.0,
            decay: 0.5 + Math.random() * 0.6,
            behavior: 'default', age: 0,
          });
        }
      } else {
        // ── TIER 1: SIMPLE POP ──
        // Small cyan burst (original style)
        spawnParticles(pos, 0x4fc3f7, 20 + streak * 5);
      }
      // Cap total
      while (particles.length > MAX_PARTICLES) particles.shift();
    }

    // ── Raycaster for Mouse Interaction ─────────────────────────
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ── Score Pop Text (CSS) ────────────────────────────────────
    const messageEl = document.getElementById('message');
    function showMessage(text, color) {
      messageEl.textContent = text;
      messageEl.style.color = color || '#fff';
      messageEl.style.opacity = 1;
      setTimeout(() => { messageEl.style.opacity = 0; }, 800);
    }

    // ── Click Handler ───────────────────────────────────────────
    renderer.domElement.addEventListener('click', (e) => {
      if (!state.running) return;

      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(ball);

      // Forgiving hitbox: if ray passes close to ball center, count as hit
      let nearHit = false;
      if (hits.length === 0) {
        const ray = raycaster.ray;
        const closest = new THREE.Vector3();
        ray.closestPointToPoint(ball.position, closest);
        const dist = closest.distanceTo(ball.position);
        const forgiveness = currentBallRadius * 1.5; // 50% larger effective hitbox
        if (dist < forgiveness) nearHit = true;
      }

      if (hits.length > 0 || nearHit) {
        catchBall();
      } else {
        // Miss
        state.streak = 0;
        state.missStreak++;

        // Mercy mechanic: grow ball every 3 consecutive misses
        if (state.missStreak % 3 === 0 && currentBallRadius < BALL_MAX_RADIUS) {
          currentBallRadius = Math.min(currentBallRadius + MERCY_GROW_STEP, BALL_MAX_RADIUS);
          ball.scale.setScalar(currentBallRadius);
          ball.geometry.computeBoundingSphere();
          showMessage('MERCY +SIZE', '#ff8a65');
        }

        updateHUD();
      }
    });

    function catchBall() {
      state.streak++;
      state.missStreak = 0;
      const streakMult = Math.min(state.streak, 10);

      // Size multiplier: smaller ball = higher score (linear)
      const normalizedSize = (currentBallRadius - BALL_MIN_RADIUS) / (BALL_MAX_RADIUS - BALL_MIN_RADIUS);
      const sizeMult = 1 + SIZE_COEFF * (1 - normalizedSize);

      // Time multiplier: longer time = lower score (linear)
      const elapsed = clock.elapsedTime - ballSpawnTime;
      const timeMult = Math.max(TIME_MIN_MULT, 1 - TIME_COEFF * elapsed);

      const points = Math.round(10 * streakMult * sizeMult * timeMult);
      state.score += points;
      if (state.streak > state.bestStreak) state.bestStreak = state.streak;

      updateHUD();

      // Feedback — show breakdown
      const sizeLabel = sizeMult >= 3 ? 'TINY' : sizeMult >= 2 ? 'SMALL' : 'BIG';
      const timeLabel = timeMult >= 0.7 ? 'FAST' : timeMult >= 0.4 ? '' : 'SLOW';
      let msg = `+${points}`;
      if (streakMult >= 5) msg += ` x${streakMult}`;
      if (sizeMult >= 2) msg += ` ${sizeLabel}!`;
      if (timeLabel === 'FAST') msg += ' QUICK!';
      // Element-themed message colors matching streak tier
      let msgColor;
      if (state.streak >= 22) { msgColor = '#ffffff'; }       // Storm — white
      else if (state.streak >= 17) { msgColor = '#7affa0'; }  // Wind — green
      else if (state.streak >= 12) { msgColor = '#82b1ff'; }  // Electric — blue
      else if (state.streak >= 8)  { msgColor = '#80deea'; }  // Ice — cyan
      else if (state.streak >= 5)  { msgColor = '#ff8a65'; }  // Fire — orange
      else if (sizeMult >= 3) { msgColor = '#ff9800'; }
      else { msgColor = '#4fc3f7'; }
      showMessage(msg, msgColor);

      // Particles — streak-based explosions
      streakExplosion(ballPos.clone(), state.streak);

      // Flash ball
      ballMat.emissiveIntensity = 1.0;

      // Relaunch ball — new random size, position, velocity
      randomizeBallSize();
      ballSpawnTime = clock.elapsedTime;

      ballPos.set(
        (Math.random() - 0.5) * (ROOM.w - 2),
        ROOM.h * 0.4 + Math.random() * 2,
        (Math.random() - 0.3) * (ROOM.d - 2)
      );
      ballVel.set(
        (Math.random() - 0.5) * 5,
        (Math.random() - 0.5) * 4 + 2,
        (Math.random() - 0.5) * 5
      );
    }

    // ── HUD Update ──────────────────────────────────────────────
    function updateHUD() {
      document.getElementById('score-value').textContent = state.score;
      document.getElementById('streak-value').textContent = state.streak;
    }

    function updateTimerHUD() {
      state.sessionTime = clock.elapsedTime - state.sessionStart;
      document.getElementById('time-value').textContent = formatTime(state.sessionTime);
    }

    // Live bonus display updated every frame
    function updateBonusHUD() {
      const normalizedSize = (currentBallRadius - BALL_MIN_RADIUS) / (BALL_MAX_RADIUS - BALL_MIN_RADIUS);
      const sizeMult = 1 + SIZE_COEFF * (1 - normalizedSize);
      const elapsed = clock.elapsedTime - ballSpawnTime;
      const timeMult = Math.max(TIME_MIN_MULT, 1 - TIME_COEFF * elapsed);
      const totalBonus = sizeMult * timeMult;
      const bonusEl = document.getElementById('bonus-value');
      bonusEl.textContent = `x${totalBonus.toFixed(1)}`;
      bonusEl.classList.toggle('low', timeMult < 0.4);
    }

    // ── Resize Handler ──────────────────────────────────────────
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ── Screen Helpers ──────────────────────────────────────────
    function showScreen(id) {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('name-screen').style.display = 'none';
      document.getElementById('leaderboard').style.display = 'none';
      document.getElementById('end-btn').style.display = 'none';
      if (id) {
        const el = document.getElementById(id);
        el.style.display = el.classList.contains('overlay') ? 'flex' : '';
      }
    }

    function startGame() {
      // Capture and persist player name
      const name = nameInput.value.trim() || 'Anonymous';
      state.playerName = name;
      localStorage.setItem(NAME_KEY, name);

      showScreen(null);
      document.getElementById('end-btn').style.display = '';
      state.running = true;
      state.score = 0;
      state.streak = 0;
      state.bestStreak = 0;
      state.missStreak = 0;
      state.sessionStart = clock.elapsedTime;
      state.sessionTime = 0;
      state.sessionStartWall = Date.now();
      randomizeBallSize();
      ballSpawnTime = clock.elapsedTime;
      ballPos.set(0, ROOM.h / 2, 0);
      ballVel.set(
        (Math.random() - 0.5) * 6,
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 6
      );
      updateHUD();
      document.getElementById('time-value').textContent = '0:00';
      document.getElementById('bonus-value').textContent = '--';

      // Start live session persistence
      saveLiveSession();
    }

    function endSession() {
      if (!state.running) return;
      state.running = false;
      state.sessionTime = clock.elapsedTime - state.sessionStart;
      clearLiveSession();
      const newFlags = recordSession(state.playerName, state.score, state.bestStreak, state.sessionTime);
      renderLeaderboard(newFlags, state.score, state.bestStreak, state.sessionTime);
      showScreen('leaderboard');
    }

    // ── Button Wiring ────────────────────────────────────────────
    const nameError = document.getElementById('name-error');

    function showNameScreen() {
      nameInput.value = localStorage.getItem(NAME_KEY) || '';
      nameError.textContent = '';
      showScreen('name-screen');
      nameInput.focus();
    }

    function tryStartFromName() {
      const name = nameInput.value.trim();
      if (!name) {
        nameError.textContent = 'Please enter a name to play.';
        nameInput.focus();
        return;
      }
      nameError.textContent = '';
      startGame();
    }

    document.getElementById('start-btn').addEventListener('click', showNameScreen);
    document.getElementById('start-lb-btn').addEventListener('click', () => {
      renderLeaderboard(null, null, null, null);
      showScreen('leaderboard');
    });
    document.getElementById('name-go-btn').addEventListener('click', tryStartFromName);
    document.getElementById('name-cancel-btn').addEventListener('click', () => showScreen('start-screen'));
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') tryStartFromName(); });
    document.getElementById('end-btn').addEventListener('click', endSession);
    document.getElementById('lb-play-btn').addEventListener('click', showNameScreen);
    document.getElementById('lb-back-btn').addEventListener('click', () => showScreen('start-screen'));
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && state.running) endSession(); });

    // ── Crash / Tab-close Recovery ───────────────────────────────
    // Save live session periodically (every 5s) and on every visibility change / tab close
    setInterval(saveLiveSession, 5000);
    window.addEventListener('beforeunload', saveLiveSession);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') saveLiveSession();
    });

    // ── Animation Loop ──────────────────────────────────────────
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      if (state.running) {
        // ── Ball Physics ──────────────────────────────
        ballVel.y += gravity * dt;
        ballVel.multiplyScalar(airDrag);

        ballPos.addScaledVector(ballVel, dt);

        // Bounce off walls
        const halfW = ROOM.w / 2 - currentBallRadius;
        const halfD = ROOM.d / 2 - currentBallRadius;

        if (ballPos.x < -halfW) { ballPos.x = -halfW; ballVel.x = Math.abs(ballVel.x) * restitution; }
        if (ballPos.x > halfW)  { ballPos.x = halfW;  ballVel.x = -Math.abs(ballVel.x) * restitution; }
        if (ballPos.z < -halfD) { ballPos.z = -halfD; ballVel.z = Math.abs(ballVel.z) * restitution; }
        if (ballPos.z > halfD)  { ballPos.z = halfD;  ballVel.z = -Math.abs(ballVel.z) * restitution; }

        // Floor bounce
        if (ballPos.y < currentBallRadius) {
          ballPos.y = currentBallRadius;
          ballVel.y = Math.abs(ballVel.y) * restitution;
          // Ensure it keeps bouncing
          if (ballVel.y < minBounceVel) ballVel.y = minBounceVel + Math.random() * 2;
          // Add random horizontal kick to keep it interesting
          ballVel.x += (Math.random() - 0.5) * 1.2;
          ballVel.z += (Math.random() - 0.5) * 1.2;
        }

        // Ceiling bounce
        if (ballPos.y > ROOM.h - currentBallRadius) {
          ballPos.y = ROOM.h - currentBallRadius;
          ballVel.y = -Math.abs(ballVel.y) * restitution;
        }

        ball.position.copy(ballPos);

        // Shadow blob follows ball on floor
        shadowBlob.position.x = ballPos.x;
        shadowBlob.position.z = ballPos.z;
        const shadowScale = 1.0 - (ballPos.y / ROOM.h) * 0.5;
        shadowBlob.scale.set(shadowScale, shadowScale, 1);
        shadowBlobMat.opacity = 0.3 * (1.0 - ballPos.y / ROOM.h);

        // Ease emissive back
        ballMat.emissiveIntensity += (0.15 - ballMat.emissiveIntensity) * 3 * dt;

        // Ball rotation
        ball.rotation.x += ballVel.z * dt;
        ball.rotation.z -= ballVel.x * dt;

        // ── Particles ─────────────────────────────────
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.age = (p.age || 0) + dt;
          const b = p.behavior || 'default';

          if (b === 'fire') {
            // Fire: rises, slows horizontally, flickers color
            p.vel.y += 4 * dt; // buoyancy — rises instead of falling
            p.vel.x *= 0.96; p.vel.z *= 0.96; // drag
            p.vel.x += (Math.random() - 0.5) * 6 * dt; // flicker
            p.vel.z += (Math.random() - 0.5) * 6 * dt;
            // Shift color: yellow → orange → red as life fades
            const t = p.life;
            p.color.r = 1;
            p.color.g = t * 0.7;
            p.color.b = t * 0.15;
          } else if (b === 'ember') {
            // Embers: float up slowly, gentle sway
            p.vel.y += 1.5 * dt;
            p.vel.x += Math.sin(p.age * 5 + p.seed) * 2 * dt;
            p.vel.z += Math.cos(p.age * 5 + p.seed) * 2 * dt;
            p.vel.multiplyScalar(0.98);
          } else if (b === 'ice') {
            // Ice: gentle gravity, drifts sideways, sparkles
            p.vel.y -= 3 * dt;
            p.vel.x += Math.sin(p.age * 3 + p.seed) * 1.5 * dt;
            p.vel.z += Math.cos(p.age * 4 + p.seed) * 1.5 * dt;
            p.vel.multiplyScalar(0.97);
            // Shimmer: pulse brightness
            const shimmer = 0.7 + 0.3 * Math.sin(p.age * 15 + p.seed * 10);
            p.color.r = 0.6 * shimmer;
            p.color.g = 0.85 * shimmer;
            p.color.b = 1.0 * shimmer;
          } else if (b === 'frost') {
            // Frost crystals: expand outward slowly, barely fall
            p.vel.y -= 1 * dt;
            p.vel.multiplyScalar(0.95);
          } else if (b === 'electric') {
            // Electric: zigzag erratically, bright flashes
            p.vel.x += (Math.random() - 0.5) * 40 * dt;
            p.vel.y += (Math.random() - 0.5) * 30 * dt;
            p.vel.z += (Math.random() - 0.5) * 40 * dt;
            p.vel.multiplyScalar(0.92);
            // Flash between white and blue/purple
            const flash = Math.random();
            if (flash > 0.7) { p.color.r = 1; p.color.g = 1; p.color.b = 1; }
            else { p.color.r = 0.4; p.color.g = 0.5 + Math.random() * 0.3; p.color.b = 1; }
          } else if (b === 'bolt') {
            // Lightning bolt segments: fast, short-lived
            p.vel.multiplyScalar(0.85);
            const flash = Math.random() > 0.5 ? 1 : 0.6;
            p.color.r = 0.8 * flash; p.color.g = 0.9 * flash; p.color.b = flash;
          } else if (b === 'wind') {
            // Wind: spiral outward, float up
            const angle = Math.atan2(p.vel.z, p.vel.x) + 2.5 * dt;
            const spd = Math.sqrt(p.vel.x * p.vel.x + p.vel.z * p.vel.z);
            p.vel.x = Math.cos(angle) * spd;
            p.vel.z = Math.sin(angle) * spd;
            p.vel.y += 2 * dt;
            p.vel.multiplyScalar(0.99);
            // Color shifts: white → cyan → green wisps
            const wt = p.life;
            p.color.r = 0.7 * wt;
            p.color.g = 0.9 + 0.1 * Math.sin(p.age * 6);
            p.color.b = 0.8 * wt + 0.2;
          } else if (b === 'leaf') {
            // Leaf: floats, wobbles, slow fall
            p.vel.y -= 2 * dt;
            p.vel.x += Math.sin(p.age * 4 + p.seed) * 3 * dt;
            p.vel.z += Math.cos(p.age * 3 + p.seed * 2) * 3 * dt;
            p.vel.multiplyScalar(0.97);
          } else {
            // Default: normal gravity
            p.vel.y -= 10 * dt;
          }

          p.pos.addScaledVector(p.vel, dt);
          p.life -= p.decay * dt;
          if (p.life <= 0) { particles.splice(i, 1); }
        }

        // Update particle buffers
        for (let i = 0; i < MAX_PARTICLES; i++) {
          if (i < particles.length) {
            const p = particles[i];
            particlePositions[i * 3] = p.pos.x;
            particlePositions[i * 3 + 1] = p.pos.y;
            particlePositions[i * 3 + 2] = p.pos.z;
            particleColors[i * 3] = p.color.r * p.life;
            particleColors[i * 3 + 1] = p.color.g * p.life;
            particleColors[i * 3 + 2] = p.color.b * p.life;
          } else {
            particlePositions[i * 3] = 0;
            particlePositions[i * 3 + 1] = -100;
            particlePositions[i * 3 + 2] = 0;
          }
        }
        particleGeo.attributes.position.needsUpdate = true;
        particleGeo.attributes.color.needsUpdate = true;

        // ── Live HUD updates ────────────────────────────
        updateTimerHUD();
        updateBonusHUD();

        // ── Accent light pulse ────────────────────────
        const t = clock.elapsedTime;
        accentLight1.intensity = 12 + Math.sin(t * 1.5) * 5;
        accentLight2.intensity = 12 + Math.cos(t * 1.8) * 5;
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
