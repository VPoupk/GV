<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Bouncing Ball - Catch Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    canvas { display: block; cursor: crosshair; }

    #hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 10;
      pointer-events: none;
    }
    .hud-item {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 10px 20px;
      color: #fff;
      text-align: center;
    }
    .hud-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 2px;
    }
    .hud-value {
      font-size: 28px;
      font-weight: 700;
    }
    #score-value { color: #4fc3f7; }
    #streak-value { color: #ffb74d; }
    #time-value { color: #80cbc4; }
    #bonus-value { color: #66bb6a; transition: color 0.3s; }
    #bonus-value.low { color: #ef5350; }

    #message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 22px;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      z-index: 10;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
      transition: opacity 0.3s;
    }

    .overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      color: #fff;
      overflow-y: auto;
      padding: 30px 10px;
    }
    .overlay h1 {
      font-size: 48px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #4fc3f7, #ce93d8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .overlay p {
      font-size: 18px;
      color: rgba(255,255,255,0.6);
      margin-bottom: 30px;
    }
    .overlay-btn {
      padding: 14px 40px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 30px;
      background: linear-gradient(135deg, #4fc3f7, #7c4dff);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin: 6px;
    }
    .overlay-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(79, 195, 247, 0.4);
    }
    .overlay-btn.secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .overlay-btn.secondary:hover {
      background: rgba(255,255,255,0.18);
      box-shadow: none;
    }

    #name-input {
      padding: 12px 20px;
      font-size: 18px;
      font-weight: 600;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      background: rgba(255,255,255,0.08);
      color: #fff;
      text-align: center;
      outline: none;
      width: 220px;
      margin-bottom: 20px;
      transition: border-color 0.2s;
    }
    #name-input::placeholder { color: rgba(255,255,255,0.3); }
    #name-input:focus { border-color: rgba(79,195,247,0.6); }

    #end-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 15;
      padding: 8px 20px;
      font-size: 14px;
      font-weight: 600;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 20px;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(8px);
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      display: none;
    }
    #end-btn:hover { background: rgba(239,83,80,0.4); color: #fff; }

    /* Screens - hidden by default (shown via JS) */
    #name-screen { display: none; }
    #leaderboard { display: none; justify-content: flex-start; }
    #leaderboard h1 { margin-bottom: 6px; flex-shrink: 0; }
    .lb-session-summary {
      margin-bottom: 24px;
      text-align: center;
      line-height: 1.8;
    }
    .lb-session-summary span {
      display: inline-block;
      background: rgba(255,255,255,0.08);
      border-radius: 8px;
      padding: 4px 14px;
      margin: 0 6px;
      font-weight: 600;
    }
    .lb-columns {
      display: flex;
      gap: 24px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .lb-col {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      padding: 18px 22px;
      min-width: 200px;
      text-align: center;
    }
    .lb-col h3 {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255,255,255,0.5);
      margin-bottom: 12px;
    }
    .lb-col ol {
      list-style: none;
      padding: 0;
    }
    .lb-col li {
      padding: 6px 0;
      font-size: 16px;
      font-weight: 600;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex;
      justify-content: space-between;
      gap: 16px;
    }
    .lb-col li:last-child { border-bottom: none; }
    .lb-rank { color: rgba(255,255,255,0.35); font-size: 13px; }
    .lb-val { color: #4fc3f7; }
    .lb-col.streak .lb-val { color: #ffb74d; }
    .lb-col.session .lb-val { color: #80cbc4; }
    .lb-name { color: rgba(255,255,255,0.7); font-size: 14px; flex: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .lb-new { color: #66bb6a; font-size: 11px; margin-left: 6px; }

    /* Grand Champion */
    .grand-champion {
      background: linear-gradient(135deg, rgba(255,215,0,0.12), rgba(255,180,0,0.06));
      border: 1px solid rgba(255,215,0,0.35);
      border-radius: 16px;
      padding: 18px 30px;
      margin-bottom: 24px;
      text-align: center;
      position: relative;
      overflow: hidden;
      min-width: 320px;
    }
    .grand-champion::before {
      content: '';
      position: absolute;
      top: -50%; left: -50%;
      width: 200%; height: 200%;
      background: conic-gradient(from 0deg, transparent, rgba(255,215,0,0.06), transparent, rgba(255,215,0,0.06), transparent);
      animation: gc-shimmer 6s linear infinite;
    }
    @keyframes gc-shimmer { to { transform: rotate(360deg); } }
    .grand-champion > * { position: relative; z-index: 1; }
    .gc-crown { font-size: 28px; margin-bottom: 4px; }
    .gc-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 3px;
      background: linear-gradient(90deg, #ffd700, #ffaa00, #ffd700);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .gc-name {
      font-size: 22px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 8px;
    }
    .gc-stats {
      display: flex;
      gap: 18px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .gc-stat {
      display: inline-block;
      background: rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 4px 14px;
      font-weight: 600;
      font-size: 14px;
    }
    .gc-stat .gc-label { color: rgba(255,255,255,0.4); font-size: 10px; text-transform: uppercase; letter-spacing: 1px; display: block; }
    .gc-stat .gc-val { color: #ffd700; }
    .gc-empty {
      color: rgba(255,215,0,0.4);
      font-size: 14px;
      font-style: italic;
    }
    .gc-new-badge {
      display: inline-block;
      background: linear-gradient(135deg, #ffd700, #ffaa00);
      color: #000;
      font-size: 10px;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: 8px;
      vertical-align: middle;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* VIP Pass Card */
    .vip-card {
      background: linear-gradient(135deg, rgba(156,39,176,0.15), rgba(233,30,99,0.08));
      border: 1px solid rgba(206,147,216,0.4);
      border-radius: 18px;
      padding: 20px 28px;
      margin-top: 24px;
      text-align: center;
      position: relative;
      overflow: hidden;
      max-width: 360px;
      width: 100%;
    }
    .vip-card::before {
      content: '';
      position: absolute;
      top: -50%; left: -50%;
      width: 200%; height: 200%;
      background: conic-gradient(from 0deg, transparent, rgba(206,147,216,0.05), transparent, rgba(233,30,99,0.05), transparent);
      animation: vip-shimmer 8s linear infinite;
    }
    @keyframes vip-shimmer { to { transform: rotate(360deg); } }
    .vip-card > * { position: relative; z-index: 1; }
    .vip-icon { font-size: 26px; margin-bottom: 4px; }
    .vip-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 3px;
      background: linear-gradient(90deg, #ce93d8, #f48fb1, #ce93d8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
      margin-bottom: 6px;
    }
    .vip-desc {
      font-size: 13px;
      color: rgba(255,255,255,0.55);
      margin-bottom: 12px;
      line-height: 1.5;
    }
    .vip-perks {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 14px;
    }
    .vip-perk {
      background: rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 4px 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      font-weight: 600;
    }
    .vip-btn {
      padding: 12px 36px;
      font-size: 16px;
      font-weight: 700;
      border: none;
      border-radius: 30px;
      background: linear-gradient(135deg, #ce93d8, #e91e63);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      letter-spacing: 0.5px;
    }
    .vip-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(233,30,99,0.4);
    }
    .vip-price {
      font-size: 12px;
      color: rgba(255,255,255,0.35);
      margin-top: 8px;
    }
    .vip-active-badge {
      display: inline-block;
      background: linear-gradient(135deg, #ce93d8, #e91e63);
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      padding: 3px 12px;
      border-radius: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 6px;
    }

    /* VIP Purchase Overlay */
    .vip-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(8px);
      z-index: 9999;
      justify-content: center;
      align-items: center;
    }
    .vip-overlay.show { display: flex; }
    .vip-modal {
      background: linear-gradient(160deg, #1a1a2e, #16213e);
      border: 1px solid rgba(206,147,216,0.3);
      border-radius: 24px;
      padding: 36px 32px;
      max-width: 380px;
      width: 90%;
      text-align: center;
      position: relative;
      animation: vip-pop 0.35s cubic-bezier(0.34,1.56,0.64,1);
    }
    @keyframes vip-pop {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .vip-modal-icon { font-size: 48px; margin-bottom: 8px; }
    .vip-modal-title {
      font-size: 22px;
      font-weight: 800;
      background: linear-gradient(90deg, #ffd700, #f48fb1, #ce93d8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 6px;
    }
    .vip-modal-price {
      font-size: 32px;
      font-weight: 800;
      color: #fff;
      margin: 10px 0;
    }
    .vip-modal-price small {
      font-size: 14px;
      color: rgba(255,255,255,0.4);
      font-weight: 400;
    }
    .vip-modal-perks {
      list-style: none;
      padding: 0;
      margin: 18px 0 24px;
      text-align: left;
    }
    .vip-modal-perks li {
      padding: 8px 0;
      font-size: 15px;
      color: rgba(255,255,255,0.85);
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .vip-modal-perks li:last-child { border-bottom: none; }
    .vip-modal-perks .perk-icon { font-size: 20px; flex-shrink: 0; }
    .vip-confirm-btn {
      width: 100%;
      padding: 16px;
      font-size: 18px;
      font-weight: 800;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, #ffd700, #e91e63);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      letter-spacing: 0.5px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }
    .vip-confirm-btn:hover {
      transform: scale(1.03);
      box-shadow: 0 0 40px rgba(233,30,99,0.5);
    }
    .vip-cancel-btn {
      margin-top: 14px;
      background: none;
      border: none;
      color: rgba(255,255,255,0.35);
      font-size: 14px;
      cursor: pointer;
      padding: 8px 20px;
    }
    .vip-cancel-btn:hover { color: rgba(255,255,255,0.6); }
    .vip-success {
      animation: vip-success-pop 0.5s ease;
    }
    @keyframes vip-success-pop {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    /* Combo Timer Bar */
    #combo-bar-wrap {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 220px;
      height: 6px;
      background: rgba(255,255,255,0.08);
      border-radius: 3px;
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #combo-bar-wrap.visible { opacity: 1; }
    #combo-bar {
      height: 100%;
      border-radius: 3px;
      background: linear-gradient(90deg, #4fc3f7, #7c4dff);
      width: 100%;
      transition: background 0.3s;
    }
    #combo-bar.urgent { background: linear-gradient(90deg, #ef5350, #ff7043); }
    #combo-label {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255,255,255,0.3);
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #combo-label.visible { opacity: 1; }

    /* Floating Score Popups */
    .float-score {
      position: fixed;
      font-size: 22px;
      font-weight: 800;
      pointer-events: none;
      z-index: 12;
      text-shadow: 0 2px 12px rgba(0,0,0,0.5);
      animation: float-up 1s ease-out forwards;
      white-space: nowrap;
    }
    @keyframes float-up {
      0% { opacity: 1; transform: translateY(0) scale(1.2); }
      60% { opacity: 1; transform: translateY(-60px) scale(1); }
      100% { opacity: 0; transform: translateY(-100px) scale(0.8); }
    }

    /* Achievement Toasts */
    #achievement-container {
      position: fixed;
      top: 90px;
      right: 20px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    .achievement-toast {
      background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,180,0,0.08));
      border: 1px solid rgba(255,215,0,0.4);
      border-radius: 14px;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      animation: toast-in 0.5s cubic-bezier(0.34,1.56,0.64,1), toast-out 0.4s ease 3.5s forwards;
      backdrop-filter: blur(10px);
      min-width: 220px;
    }
    @keyframes toast-in {
      from { transform: translateX(120%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes toast-out {
      to { transform: translateX(120%); opacity: 0; }
    }
    .achievement-icon { font-size: 28px; flex-shrink: 0; }
    .achievement-info { display: flex; flex-direction: column; }
    .achievement-title {
      font-size: 13px;
      font-weight: 800;
      color: #ffd700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .achievement-desc {
      font-size: 12px;
      color: rgba(255,255,255,0.55);
      margin-top: 2px;
    }

    /* Stats Page */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      max-width: 380px;
      width: 100%;
      margin: 16px auto 20px;
    }
    .stat-card {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 16px;
      text-align: center;
    }
    .stat-card-value {
      font-size: 28px;
      font-weight: 800;
      color: #4fc3f7;
    }
    .stat-card-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255,255,255,0.4);
      margin-top: 4px;
    }
    .stat-card.gold .stat-card-value { color: #ffd700; }
    .stat-card.purple .stat-card-value { color: #ce93d8; }
    .stat-card.green .stat-card-value { color: #66bb6a; }
    .stat-card.orange .stat-card-value { color: #ffb74d; }
    .stat-card.cyan .stat-card-value { color: #80cbc4; }
  </style>
</head>
<body>
  <div id="start-screen" class="overlay">
    <h1>Bouncing Ball</h1>
    <p>Catch the ball fast! Smaller ball = more points, quicker catch = higher bonus</p>
    <div>
      <button id="start-btn" class="overlay-btn">Play</button>
      <button id="start-lb-btn" class="overlay-btn secondary">Leaderboard</button>
      <button id="start-stats-btn" class="overlay-btn secondary">Stats</button>
    </div>
    <div class="vip-card" id="vip-card">
      <div class="vip-icon">&#x2B50;</div>
      <div class="vip-label">VIP Pass</div>
      <div class="vip-desc">Unlock exclusive perks and stand out on the leaderboard</div>
      <div class="vip-perks">
        <span class="vip-perk">&#x2B50; VIP Badge</span>
        <span class="vip-perk">&#x1F451; Gold Name</span>
        <span class="vip-perk">&#x1F525; 2x Score</span>
      </div>
      <div id="vip-btn-area">
        <button class="vip-btn" id="vip-buy-btn">Get VIP — £0.99</button>
        <div class="vip-price">One-time purchase</div>
      </div>
    </div>
  </div>

  <div id="name-screen" class="overlay">
    <h1>Enter Your Name</h1>
    <p>Choose a name before you start playing</p>
    <input id="name-input" type="text" placeholder="Your name" maxlength="16" autocomplete="off" spellcheck="false">
    <div id="name-error" style="color:#ef5350;font-size:14px;margin-bottom:12px;min-height:20px;"></div>
    <div>
      <button id="name-go-btn" class="overlay-btn">Start</button>
      <button id="name-cancel-btn" class="overlay-btn secondary">Back</button>
    </div>
  </div>

  <div id="leaderboard" class="overlay">
    <h1>Leaderboard</h1>
    <div class="lb-session-summary" id="lb-session-summary"></div>
    <div id="gc-container"></div>
    <div class="lb-columns" id="lb-columns"></div>
    <div>
      <button id="lb-play-btn" class="overlay-btn">Play Again</button>
      <button id="lb-back-btn" class="overlay-btn secondary">Main Menu</button>
    </div>
  </div>

  <div id="stats-screen" class="overlay" style="display:none;">
    <h1>All-Time Stats</h1>
    <div class="stats-grid" id="stats-grid"></div>
    <div id="stats-achievements" style="max-width:380px;width:100%;margin-bottom:20px;"></div>
    <div>
      <button id="stats-back-btn" class="overlay-btn secondary">Back</button>
    </div>
  </div>

  <button id="end-btn">End Session</button>

  <div id="hud">
    <div class="hud-item">
      <div class="hud-label">Score</div>
      <div class="hud-value" id="score-value">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Streak</div>
      <div class="hud-value" id="streak-value">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Time</div>
      <div class="hud-value" id="time-value">0:00</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Bonus</div>
      <div class="hud-value" id="bonus-value">--</div>
    </div>
  </div>

  <div id="message"></div>

  <!-- Combo Timer -->
  <div id="combo-label" class="">COMBO</div>
  <div id="combo-bar-wrap" class="">
    <div id="combo-bar"></div>
  </div>

  <!-- Achievement Toasts -->
  <div id="achievement-container"></div>

  <!-- Mute Button -->
  <button id="mute-btn" style="position:fixed;bottom:20px;right:20px;z-index:15;padding:8px 14px;font-size:18px;border:1px solid rgba(255,255,255,0.15);border-radius:12px;background:rgba(0,0,0,0.5);backdrop-filter:blur(8px);color:rgba(255,255,255,0.6);cursor:pointer;display:none;" title="Toggle Sound">&#x1F50A;</button>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ── Game State ──────────────────────────────────────────────
    const state = {
      score: 0,
      streak: 0,
      bestStreak: 0,
      missStreak: 0,         // consecutive misses — grows ball every 5
      running: false,
      sessionStart: 0,       // clock.elapsedTime when Play was pressed
      sessionTime: 0,        // seconds of current session
      sessionStartWall: 0,   // Date.now() when Play was pressed (for crash recovery)
      playerName: '',
    };

    // ── Name persistence ──────────────────────────────────────
    const NAME_KEY = 'bouncingBall_playerName';
    const nameInput = document.getElementById('name-input');
    nameInput.value = localStorage.getItem(NAME_KEY) || '';

    // ── VIP Pass ─────────────────────────────────────────────
    const VIP_KEY = 'bouncingBall_vip';
    function isVIP() { return localStorage.getItem(VIP_KEY) === 'true'; }

    function updateVIPCard() {
      const btnArea = document.getElementById('vip-btn-area');
      if (isVIP()) {
        btnArea.innerHTML = '<div class="vip-active-badge">VIP Active</div>';
      }
    }

    const vipOverlay = document.getElementById('vip-overlay');
    const vipModal = document.getElementById('vip-modal');

    document.getElementById('vip-buy-btn').addEventListener('click', () => {
      vipOverlay.classList.add('show');
    });

    document.getElementById('vip-cancel-btn').addEventListener('click', () => {
      vipOverlay.classList.remove('show');
    });

    vipOverlay.addEventListener('click', (e) => {
      if (e.target === vipOverlay) vipOverlay.classList.remove('show');
    });

    document.getElementById('vip-confirm-btn').addEventListener('click', () => {
      // ── PAYMENT: Replace this block with your Stripe/PayPal checkout ──
      // Example: window.open('https://buy.stripe.com/YOUR_LINK', '_blank');
      // Then activate VIP only after payment confirmation.
      // For now, activates VIP directly (beta/free mode):
      localStorage.setItem(VIP_KEY, 'true');
      updateVIPCard();

      // Success animation
      vipModal.innerHTML =
        '<div style="padding:30px 0;">' +
        '<div style="font-size:64px;animation:vip-success-pop 0.5s ease;">&#x2705;</div>' +
        '<div style="font-size:22px;font-weight:800;color:#4caf50;margin:12px 0;">VIP Activated!</div>' +
        '<div style="font-size:14px;color:rgba(255,255,255,0.5);margin-bottom:20px;">All perks are now active</div>' +
        '<button onclick="document.getElementById(\'vip-overlay\').classList.remove(\'show\')" ' +
        'style="padding:12px 36px;font-size:16px;font-weight:700;border:none;border-radius:30px;' +
        'background:linear-gradient(135deg,#4caf50,#2e7d32);color:#fff;cursor:pointer;">Let\'s Go!</button>' +
        '</div>';
    });

    updateVIPCard();

    // ── Sound Effects (Web Audio API) ────────────────────────
    let audioCtx = null;
    let soundEnabled = true;
    const SOUND_KEY = 'bouncingBall_sound';
    if (localStorage.getItem(SOUND_KEY) === 'false') soundEnabled = false;

    function getAudioCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    function playTone(freq, type, dur, vol, detune) {
      if (!soundEnabled) return;
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type || 'sine';
        osc.frequency.value = freq;
        if (detune) osc.detune.value = detune;
        gain.gain.setValueAtTime(vol || 0.15, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + (dur || 0.2));
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + (dur || 0.2));
      } catch(e) {}
    }

    function playNoise(dur, vol) {
      if (!soundEnabled) return;
      try {
        const ctx = getAudioCtx();
        const bufferSize = ctx.sampleRate * (dur || 0.1);
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(vol || 0.08, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + (dur || 0.1));
        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 2000;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        source.start();
      } catch(e) {}
    }

    function sndCatch(streak) {
      const base = 440 + Math.min(streak, 20) * 30;
      playTone(base, 'sine', 0.15, 0.12);
      playTone(base * 1.5, 'sine', 0.1, 0.06);
      if (streak >= 5) playTone(base * 2, 'triangle', 0.2, 0.05);
    }
    function sndMiss() { playTone(180, 'sawtooth', 0.25, 0.08); playNoise(0.08, 0.04); }
    function sndBounce(vel) { playTone(120 + vel * 15, 'sine', 0.06, Math.min(vel * 0.01, 0.06)); }
    function sndMilestone() {
      [523, 659, 784, 1047].forEach((f, i) => {
        setTimeout(() => playTone(f, 'sine', 0.3, 0.1), i * 80);
      });
    }
    function sndComboExpire() { playTone(300, 'sawtooth', 0.3, 0.1); playTone(200, 'sawtooth', 0.4, 0.08); }

    const muteBtn = document.getElementById('mute-btn');
    muteBtn.textContent = soundEnabled ? '\u{1F50A}' : '\u{1F507}';
    muteBtn.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      localStorage.setItem(SOUND_KEY, soundEnabled);
      muteBtn.textContent = soundEnabled ? '\u{1F50A}' : '\u{1F507}';
    });

    // ── Combo Timer ──────────────────────────────────────────
    const COMBO_TIME = 5.0; // seconds to catch next ball before streak resets
    let comboTimeLeft = 0;
    let comboActive = false;
    const comboBarWrap = document.getElementById('combo-bar-wrap');
    const comboBar = document.getElementById('combo-bar');
    const comboLabel = document.getElementById('combo-label');

    function startCombo() {
      comboTimeLeft = COMBO_TIME;
      comboActive = true;
      comboBarWrap.classList.add('visible');
      comboLabel.classList.add('visible');
    }
    function stopCombo() {
      comboActive = false;
      comboBarWrap.classList.remove('visible');
      comboLabel.classList.remove('visible');
    }
    function updateCombo(dt) {
      if (!comboActive || !state.running) return;
      if (state.streak <= 0) { stopCombo(); return; }
      comboTimeLeft -= dt;
      const pct = Math.max(comboTimeLeft / COMBO_TIME, 0);
      comboBar.style.width = (pct * 100) + '%';
      comboBar.classList.toggle('urgent', pct < 0.3);
      if (comboTimeLeft <= 0) {
        // Streak expired!
        state.streak = 0;
        state.missStreak++;
        comboActive = false;
        comboBarWrap.classList.remove('visible');
        comboLabel.classList.remove('visible');
        applyBallTier('default');
        updateHUD();
        showMessage('COMBO EXPIRED', '#ef5350');
        sndComboExpire();
      }
    }

    // ── Floating Score Popups ────────────────────────────────
    function spawnFloatScore(screenX, screenY, text, color) {
      const el = document.createElement('div');
      el.className = 'float-score';
      el.textContent = text;
      el.style.color = color || '#fff';
      el.style.left = screenX + 'px';
      el.style.top = screenY + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }

    // ── Achievement / Milestone System ──────────────────────
    const STATS_KEY = 'bouncingBall_stats';
    const ACHIEVEMENTS_KEY = 'bouncingBall_achievements';

    function loadStats() {
      try { return JSON.parse(localStorage.getItem(STATS_KEY)) || defaultStats(); }
      catch { return defaultStats(); }
    }
    function defaultStats() {
      return { totalGames: 0, totalCatches: 0, totalMisses: 0, totalScore: 0, bestEverScore: 0,
               bestEverStreak: 0, totalTime: 0, longestSession: 0 };
    }
    function saveStats(s) { localStorage.setItem(STATS_KEY, JSON.stringify(s)); }

    function loadAchievements() {
      try { return JSON.parse(localStorage.getItem(ACHIEVEMENTS_KEY)) || {}; }
      catch { return {}; }
    }
    function saveAchievements(a) { localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify(a)); }

    const MILESTONES = [
      { id: 'streak3', icon: '\u{1F525}', title: 'On Fire', desc: 'Reach a 3 streak', check: (s, st) => st.bestEverStreak >= 3 },
      { id: 'streak10', icon: '\u26A1', title: 'Lightning', desc: 'Reach a 10 streak', check: (s, st) => st.bestEverStreak >= 10 },
      { id: 'streak22', icon: '\u{1F32A}', title: 'Storm Chaser', desc: 'Reach a 22 streak', check: (s, st) => st.bestEverStreak >= 22 },
      { id: 'score500', icon: '\u{1F4AF}', title: 'High Scorer', desc: 'Score 500+ in a session', check: (s, st) => st.bestEverScore >= 500 },
      { id: 'score2000', icon: '\u{1F3C6}', title: 'Champion', desc: 'Score 2000+ in a session', check: (s, st) => st.bestEverScore >= 2000 },
      { id: 'score10000', icon: '\u{1F48E}', title: 'Diamond', desc: 'Score 10000+ in a session', check: (s, st) => st.bestEverScore >= 10000 },
      { id: 'games5', icon: '\u{1F3AE}', title: 'Regular', desc: 'Play 5 games', check: (s, st) => st.totalGames >= 5 },
      { id: 'games25', icon: '\u{1F3AF}', title: 'Dedicated', desc: 'Play 25 games', check: (s, st) => st.totalGames >= 25 },
      { id: 'catches100', icon: '\u{1F44F}', title: 'Catcher', desc: '100 total catches', check: (s, st) => st.totalCatches >= 100 },
      { id: 'catches500', icon: '\u{1F31F}', title: 'Star Catcher', desc: '500 total catches', check: (s, st) => st.totalCatches >= 500 },
      { id: 'time300', icon: '\u23F0', title: 'Marathon', desc: '5 minutes in one session', check: (s, st) => st.longestSession >= 300 },
    ];

    function showAchievementToast(milestone) {
      const container = document.getElementById('achievement-container');
      const toast = document.createElement('div');
      toast.className = 'achievement-toast';
      toast.innerHTML =
        `<span class="achievement-icon">${milestone.icon}</span>` +
        `<div class="achievement-info">` +
        `<div class="achievement-title">${milestone.title}</div>` +
        `<div class="achievement-desc">${milestone.desc}</div>` +
        `</div>`;
      container.appendChild(toast);
      sndMilestone();
      setTimeout(() => toast.remove(), 4000);
    }

    function checkAchievements(stats) {
      const unlocked = loadAchievements();
      MILESTONES.forEach(m => {
        if (!unlocked[m.id] && m.check(null, stats)) {
          unlocked[m.id] = Date.now();
          showAchievementToast(m);
        }
      });
      saveAchievements(unlocked);
    }

    function renderStatsPage() {
      const stats = loadStats();
      const unlocked = loadAchievements();
      const grid = document.getElementById('stats-grid');
      grid.innerHTML =
        `<div class="stat-card"><div class="stat-card-value">${stats.totalGames}</div><div class="stat-card-label">Games Played</div></div>` +
        `<div class="stat-card gold"><div class="stat-card-value">${stats.bestEverScore.toLocaleString()}</div><div class="stat-card-label">Best Score</div></div>` +
        `<div class="stat-card orange"><div class="stat-card-value">${stats.bestEverStreak}</div><div class="stat-card-label">Best Streak</div></div>` +
        `<div class="stat-card"><div class="stat-card-value">${stats.totalCatches.toLocaleString()}</div><div class="stat-card-label">Total Catches</div></div>` +
        `<div class="stat-card purple"><div class="stat-card-value">${stats.totalScore.toLocaleString()}</div><div class="stat-card-label">Total Score</div></div>` +
        `<div class="stat-card cyan"><div class="stat-card-value">${formatTime(stats.totalTime)}</div><div class="stat-card-label">Total Time</div></div>`;

      const achEl = document.getElementById('stats-achievements');
      const achHTML = MILESTONES.map(m => {
        const done = !!unlocked[m.id];
        return `<div style="display:flex;align-items:center;gap:12px;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.06);opacity:${done ? 1 : 0.3};">` +
          `<span style="font-size:22px;">${m.icon}</span>` +
          `<div><div style="font-size:14px;font-weight:700;color:${done ? '#ffd700' : 'rgba(255,255,255,0.4)'};">${m.title}</div>` +
          `<div style="font-size:12px;color:rgba(255,255,255,0.4);">${m.desc}</div></div>` +
          `${done ? '<span style="margin-left:auto;color:#66bb6a;font-size:16px;">&#x2714;</span>' : ''}` +
          `</div>`;
      }).join('');
      achEl.innerHTML = `<h3 style="font-size:13px;text-transform:uppercase;letter-spacing:2px;color:rgba(255,255,255,0.5);margin-bottom:10px;">Achievements</h3>` + achHTML;
    }

    // Session-level catch/miss counters for stats (not stored in state to avoid altering it)
    let sessionCatches = 0;
    let sessionMisses = 0;

    // ── Leaderboard (localStorage) ────────────────────────────
    const LB_KEY = 'bouncingBall_leaderboard';
    const LIVE_KEY = 'bouncingBall_liveSession';
    const LB_MAX = 5;

    function loadLeaderboard() {
      try { return JSON.parse(localStorage.getItem(LB_KEY)) || { score: [], streak: [], session: [], champion: null }; }
      catch { return { score: [], streak: [], session: [], champion: null }; }
    }

    function saveLeaderboard(lb) {
      localStorage.setItem(LB_KEY, JSON.stringify(lb));
    }

    // Grand Champion rating: highest score & streak in the least time
    function championRating(score, streak, secs) {
      if (secs <= 0) return 0;
      return (score * streak) / secs;
    }

    // Returns { score: idx|null, streak: idx|null, session: idx|null, newChampion: bool } for new entries
    function recordSession(name, score, bestStreak, sessionSecs) {
      const lb = loadLeaderboard();
      const newFlags = { score: null, streak: null, session: null, newChampion: false };

      function insert(list, value) {
        const entry = { value, name: name || 'Anonymous', date: Date.now(), vip: isVIP() };
        let idx = list.findIndex(e => value > e.value);
        if (idx === -1) idx = list.length;
        if (idx >= LB_MAX) return null;
        list.splice(idx, 0, entry);
        if (list.length > LB_MAX) list.pop();
        return idx;
      }

      if (score > 0) newFlags.score = insert(lb.score, score);
      if (bestStreak > 0) newFlags.streak = insert(lb.streak, bestStreak);
      if (sessionSecs > 0) newFlags.session = insert(lb.session, Math.round(sessionSecs));

      // Grand Champion check
      if (score > 0 && bestStreak > 0 && sessionSecs > 0) {
        const rating = championRating(score, bestStreak, sessionSecs);
        if (!lb.champion || rating > lb.champion.rating) {
          lb.champion = {
            name: name || 'Anonymous',
            score,
            streak: bestStreak,
            time: Math.round(sessionSecs),
            rating,
            date: Date.now(),
            vip: isVIP(),
          };
          newFlags.newChampion = true;
        }
      }

      saveLeaderboard(lb);
      return newFlags;
    }

    // ── Live Session Persistence (crash/tab-close recovery) ───
    function saveLiveSession() {
      if (!state.running) return;
      const elapsed = (Date.now() - state.sessionStartWall) / 1000;
      localStorage.setItem(LIVE_KEY, JSON.stringify({
        name: state.playerName,
        score: state.score,
        bestStreak: state.bestStreak,
        startWall: state.sessionStartWall,
        elapsed,
      }));
    }

    function clearLiveSession() {
      localStorage.removeItem(LIVE_KEY);
    }

    function recoverCrashedSession() {
      try {
        const raw = localStorage.getItem(LIVE_KEY);
        if (!raw) return;
        const s = JSON.parse(raw);
        // Calculate total session time using wall-clock timestamps
        const totalSecs = (Date.now() - s.startWall) / 1000;
        // Only recover sessions that are at least 2 seconds and not absurdly old (>24h)
        if (totalSecs < 2 || totalSecs > 86400) { clearLiveSession(); return; }
        recordSession(s.name, s.score, s.bestStreak, totalSecs);
        clearLiveSession();
      } catch { clearLiveSession(); }
    }

    // Recover any orphaned session from a previous crash/tab close
    recoverCrashedSession();

    function formatTime(secs) {
      const s = Math.round(secs);
      const m = Math.floor(s / 60);
      const sec = s % 60;
      return `${m}:${sec.toString().padStart(2, '0')}`;
    }

    function escapeHtml(str) {
      return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }

    function renderLeaderboard(newFlags, sessionScore, sessionStreak, sessionSecs) {
      const lb = loadLeaderboard();
      const summaryEl = document.getElementById('lb-session-summary');
      const gcEl = document.getElementById('gc-container');
      const colsEl = document.getElementById('lb-columns');

      // Session summary (only shown if we just ended a session)
      if (sessionScore != null) {
        summaryEl.innerHTML =
          `<span style="color:#4fc3f7">Score: ${sessionScore}</span>` +
          `<span style="color:#ffb74d">Best Streak: ${sessionStreak}</span>` +
          `<span style="color:#80cbc4">Time: ${formatTime(sessionSecs)}</span>`;
        summaryEl.style.display = '';
      } else {
        summaryEl.style.display = 'none';
      }

      // Grand Champion display
      if (lb.champion) {
        const c = lb.champion;
        const isNew = newFlags && newFlags.newChampion;
        gcEl.innerHTML =
          `<div class="grand-champion">` +
            `<div class="gc-crown">&#x1F451;</div>` +
            `<div class="gc-title">Grand Champion</div>` +
            `<div class="gc-name"${c.vip ? ' style="color:#ffd700;"' : ''}>${c.vip ? '&#x2B50; ' : ''}${escapeHtml(c.name)}${isNew ? '<span class="gc-new-badge">NEW</span>' : ''}</div>` +
            `<div class="gc-stats">` +
              `<div class="gc-stat"><span class="gc-label">Score</span><span class="gc-val">${c.score.toLocaleString()}</span></div>` +
              `<div class="gc-stat"><span class="gc-label">Streak</span><span class="gc-val">${c.streak}</span></div>` +
              `<div class="gc-stat"><span class="gc-label">Time</span><span class="gc-val">${formatTime(c.time)}</span></div>` +
            `</div>` +
          `</div>`;
      } else {
        gcEl.innerHTML =
          `<div class="grand-champion">` +
            `<div class="gc-crown">&#x1F451;</div>` +
            `<div class="gc-title">Grand Champion</div>` +
            `<div class="gc-empty">No champion yet — be the first!</div>` +
          `</div>`;
      }

      const categories = [
        { key: 'score', title: 'Highest Score', cls: 'score', fmt: v => v.toLocaleString() },
        { key: 'streak', title: 'Best Streak', cls: 'streak', fmt: v => v },
        { key: 'session', title: 'Longest Session', cls: 'session', fmt: v => formatTime(v) },
      ];

      colsEl.innerHTML = categories.map(cat => {
        const rows = lb[cat.key].length > 0
          ? lb[cat.key].map((e, i) => {
              const isNew = newFlags && newFlags[cat.key] === i;
              const rawName = escapeHtml(e.name || 'Anonymous');
              const vipBadge = e.vip ? '<span style="color:#ffd700;font-size:11px;margin-right:4px;">&#x2B50;</span>' : '';
              const nameStyle = e.vip ? 'style="color:#ffd700;"' : '';
              return `<li><span class="lb-rank">#${i + 1}</span><span class="lb-name" ${nameStyle}>${vipBadge}${rawName}</span> <span class="lb-val">${cat.fmt(e.value)}${isNew ? '<span class="lb-new">NEW</span>' : ''}</span></li>`;
            }).join('')
          : '<li style="color:rgba(255,255,255,0.3)">No records yet</li>';
        return `<div class="lb-col ${cat.cls}"><h3>${cat.title}</h3><ol>${rows}</ol></div>`;
      }).join('');
    }

    // ── Room Dimensions ─────────────────────────────────────────
    const ROOM = { w: 10, h: 7, d: 10 };
    const BALL_BASE_RADIUS = 0.4;
    const BALL_MIN_RADIUS = 0.25;
    const BALL_MAX_RADIUS = 0.7;
    let currentBallRadius = BALL_BASE_RADIUS;

    // Scoring coefficients
    const SIZE_COEFF = 3.0;   // at smallest ball: 4x multiplier; at largest: 1x
    const TIME_COEFF = 0.1;   // lose 0.1x per second elapsed
    const TIME_MIN_MULT = 0.1; // time multiplier floor
    const MERCY_GROW_STEP = 0.15; // how much radius grows per 5 misses
    let ballSpawnTime = 0;     // timestamp when current ball appeared

    // ── Scene Setup ─────────────────────────────────────────────
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x1a1a2e, 0.035);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 2, ROOM.d / 2 + 4);
    camera.lookAt(0, 1, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // ── Lighting ────────────────────────────────────────────────
    const ambientLight = new THREE.AmbientLight(0x404060, 0.8);
    scene.add(ambientLight);

    const mainLight = new THREE.PointLight(0xffffff, 60, 30);
    mainLight.position.set(0, ROOM.h - 1, 0);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(1024, 1024);
    scene.add(mainLight);

    // Light fixture visual
    const bulbGeo = new THREE.SphereGeometry(0.2, 16, 16);
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
    const bulb = new THREE.Mesh(bulbGeo, bulbMat);
    bulb.position.copy(mainLight.position);
    scene.add(bulb);

    const accentLight1 = new THREE.PointLight(0x4fc3f7, 15, 15);
    accentLight1.position.set(-ROOM.w / 2 + 1, 1, -ROOM.d / 2 + 1);
    scene.add(accentLight1);

    const accentLight2 = new THREE.PointLight(0xce93d8, 15, 15);
    accentLight2.position.set(ROOM.w / 2 - 1, 1, ROOM.d / 2 - 1);
    scene.add(accentLight2);

    // ── Room Construction ───────────────────────────────────────
    const wallMat = new THREE.MeshStandardMaterial({
      color: 0x2c2c3e,
      roughness: 0.85,
      metalness: 0.05,
    });

    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x3a3a4e,
      roughness: 0.6,
      metalness: 0.1,
    });

    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Ceiling
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), wallMat);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = ROOM.h;
    scene.add(ceiling);

    // Back wall
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.h), wallMat);
    backWall.position.set(0, ROOM.h / 2, -ROOM.d / 2);
    backWall.receiveShadow = true;
    scene.add(backWall);

    // Front wall (transparent so we can see in)
    // Left wall
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.d, ROOM.h), wallMat);
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.set(-ROOM.w / 2, ROOM.h / 2, 0);
    leftWall.receiveShadow = true;
    scene.add(leftWall);

    // Right wall
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.d, ROOM.h), wallMat);
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.set(ROOM.w / 2, ROOM.h / 2, 0);
    rightWall.receiveShadow = true;
    scene.add(rightWall);

    // ── Decorative Edge Lines ───────────────────────────────────
    const edgeMat = new THREE.LineBasicMaterial({ color: 0x5a5a7a, transparent: true, opacity: 0.4 });
    function addEdge(points) {
      const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(...p)));
      scene.add(new THREE.Line(geo, edgeMat));
    }
    const hw = ROOM.w / 2, hd = ROOM.d / 2, h = ROOM.h;
    // Floor edges
    addEdge([[-hw, 0, -hd], [hw, 0, -hd]]);
    addEdge([[-hw, 0, -hd], [-hw, 0, hd]]);
    addEdge([[hw, 0, -hd], [hw, 0, hd]]);
    // Ceiling edges
    addEdge([[-hw, h, -hd], [hw, h, -hd]]);
    addEdge([[-hw, h, -hd], [-hw, h, hd]]);
    addEdge([[hw, h, -hd], [hw, h, hd]]);
    // Vertical edges
    addEdge([[-hw, 0, -hd], [-hw, h, -hd]]);
    addEdge([[hw, 0, -hd], [hw, h, -hd]]);

    // ── Ball ────────────────────────────────────────────────────
    const ballGeo = new THREE.SphereGeometry(1, 32, 32); // unit sphere, scaled dynamically
    const ballMat = new THREE.MeshStandardMaterial({
      color: 0xff5252,
      roughness: 0.2,
      metalness: 0.6,
      emissive: 0xff5252,
      emissiveIntensity: 0.15,
      transparent: true,
      opacity: 1,
    });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    ball.castShadow = true;
    ball.scale.setScalar(currentBallRadius);
    scene.add(ball);

    // Ball glow
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0xff5252,
      transparent: true,
      opacity: 0.12,
      depthWrite: false,
    });
    const glow = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), glowMat);
    glow.renderOrder = -1; // always render glow before ball
    ball.add(glow);

    // ── Streak-Based Ball Designs ─────────────────────────────
    // Ball visual tiers that match the explosion effects
    const BALL_TIERS = {
      // Tier 1 (streak 0-2): Default red
      default: { color: 0xff5252, emissive: 0xff5252, roughness: 0.2, metalness: 0.6, glowColor: 0xff5252, glowOpacity: 0.12 },
      // Tier 2 (streak 3-4): Rainbow sparkle
      sparkle: { color: 0xee82ee, emissive: 0xee44ee, roughness: 0.1, metalness: 0.8, glowColor: 0xff66ff, glowOpacity: 0.18 },
      // Tier 3 (streak 5-7): Fire
      fire: { color: 0xff6600, emissive: 0xff4400, roughness: 0.3, metalness: 0.4, glowColor: 0xff4400, glowOpacity: 0.25 },
      // Tier 4 (streak 8-11): Ice
      ice: { color: 0x88ddff, emissive: 0x44aaff, roughness: 0.05, metalness: 0.9, glowColor: 0x66ccff, glowOpacity: 0.22 },
      // Tier 5 (streak 12-16): Electric
      electric: { color: 0x6666ff, emissive: 0x4444ff, roughness: 0.15, metalness: 0.7, glowColor: 0x8888ff, glowOpacity: 0.28 },
      // Tier 6 (streak 17-21): Wind
      wind: { color: 0x66ffaa, emissive: 0x33cc77, roughness: 0.25, metalness: 0.5, glowColor: 0x66ffaa, glowOpacity: 0.20 },
      // Tier 7 (streak 22+): Elemental Storm
      storm: { color: 0xffffff, emissive: 0xaaaaff, roughness: 0.0, metalness: 1.0, glowColor: 0xffffff, glowOpacity: 0.35 },
    };

    let currentBallTier = 'default';

    function getBallTierForStreak(streak) {
      if (streak >= 22) return 'storm';
      if (streak >= 17) return 'wind';
      if (streak >= 12) return 'electric';
      if (streak >= 8) return 'ice';
      if (streak >= 5) return 'fire';
      if (streak >= 3) return 'sparkle';
      return 'default';
    }

    function applyBallTier(tierName) {
      if (tierName === currentBallTier) return;
      currentBallTier = tierName;
      const t = BALL_TIERS[tierName];
      ballMat.color.setHex(t.color);
      ballMat.emissive.setHex(t.emissive);
      ballMat.roughness = t.roughness;
      ballMat.metalness = t.metalness;
      glowMat.color.setHex(t.glowColor);
      glowMat.opacity = t.glowOpacity;
    }

    // Animated ball effect — called every frame for dynamic tier visuals
    function animateBallTier(time, dt) {
      const streak = state.streak;
      const tier = currentBallTier;

      if (tier === 'sparkle') {
        // Rainbow hue shift
        const hue = (time * 0.4) % 1;
        ballMat.color.setHSL(hue, 0.8, 0.6);
        ballMat.emissive.setHSL(hue, 0.9, 0.35);
        glowMat.color.setHSL(hue, 0.8, 0.6);

      } else if (tier === 'fire') {
        // Flickering fire glow — pulse emissive intensity + warm color shift
        const flicker = 0.3 + 0.2 * Math.sin(time * 12) + 0.1 * Math.sin(time * 23);
        ballMat.emissiveIntensity = Math.max(ballMat.emissiveIntensity, flicker);
        // Shift between orange and red-yellow
        const f = 0.5 + 0.5 * Math.sin(time * 8);
        ballMat.color.setRGB(1, 0.35 + f * 0.3, 0.05 + f * 0.1);
        ballMat.emissive.setRGB(1, 0.25 + f * 0.2, 0.0);
        glowMat.color.setRGB(1, 0.3 + f * 0.2, 0.05);
        glowMat.opacity = 0.2 + 0.1 * Math.sin(time * 15);

      } else if (tier === 'ice') {
        // Crystalline shimmer — subtle sparkle in emissive
        const shimmer = 0.6 + 0.4 * Math.sin(time * 10 + Math.sin(time * 3) * 2);
        ballMat.emissive.setRGB(0.25 * shimmer, 0.5 * shimmer, 0.9 * shimmer);
        ballMat.emissiveIntensity = Math.max(ballMat.emissiveIntensity, 0.15 + shimmer * 0.15);
        // Slight color oscillation
        ballMat.color.setRGB(0.5 + 0.1 * shimmer, 0.85 + 0.1 * shimmer, 1.0);
        glowMat.opacity = 0.18 + 0.08 * shimmer;

      } else if (tier === 'electric') {
        // Random bright flashes + jitter between blue and purple
        const flash = Math.random();
        if (flash > 0.92) {
          // Bright white flash
          ballMat.emissiveIntensity = 1.0;
          ballMat.emissive.setRGB(1, 1, 1);
          glowMat.color.setRGB(1, 1, 1);
          glowMat.opacity = 0.45;
        } else {
          // Normal blue-purple pulse
          const pulse = 0.5 + 0.5 * Math.sin(time * 14);
          ballMat.color.setRGB(0.3 + pulse * 0.2, 0.3 + pulse * 0.1, 0.9 + pulse * 0.1);
          ballMat.emissive.setRGB(0.2 + pulse * 0.3, 0.2 + pulse * 0.1, 0.8 + pulse * 0.2);
          glowMat.color.setRGB(0.4, 0.4 + pulse * 0.2, 1.0);
          glowMat.opacity = 0.22 + pulse * 0.1;
        }

      } else if (tier === 'wind') {
        // Swirling green-cyan color shift
        const sw = time * 3;
        const r = 0.3 + 0.2 * Math.sin(sw);
        const g = 0.85 + 0.15 * Math.sin(sw + 2);
        const b = 0.55 + 0.2 * Math.sin(sw + 4);
        ballMat.color.setRGB(r, g, b);
        ballMat.emissive.setRGB(r * 0.5, g * 0.6, b * 0.5);
        glowMat.color.setRGB(r, g, b);
        glowMat.opacity = 0.16 + 0.08 * Math.sin(time * 5);
        // Gentle emissive pulse
        ballMat.emissiveIntensity = Math.max(ballMat.emissiveIntensity, 0.2 + 0.1 * Math.sin(time * 4));

      } else if (tier === 'storm') {
        // Elemental storm: rapidly cycles through all element colors
        const cycle = (time * 2) % 4; // 4 elements, each 1 second
        let cr, cg, cb;
        if (cycle < 1) {
          // Fire phase
          const t = cycle;
          cr = 1; cg = 0.4 + t * 0.3; cb = 0.1;
        } else if (cycle < 2) {
          // Ice phase
          const t = cycle - 1;
          cr = 0.5 + 0.2 * t; cg = 0.85; cb = 1.0;
        } else if (cycle < 3) {
          // Electric phase
          const t = cycle - 2;
          cr = 0.4 + 0.4 * t; cg = 0.4 + 0.3 * t; cb = 1.0;
        } else {
          // Wind phase
          const t = cycle - 3;
          cr = 0.4; cg = 0.9 + 0.1 * t; cb = 0.65 + 0.15 * t;
        }
        ballMat.color.setRGB(cr, cg, cb);
        ballMat.emissive.setRGB(cr * 0.7, cg * 0.7, cb * 0.7);
        glowMat.color.setRGB(cr, cg, cb);
        // Intense pulsing glow
        const stormPulse = 0.6 + 0.4 * Math.sin(time * 10);
        ballMat.emissiveIntensity = Math.max(ballMat.emissiveIntensity, 0.3 + stormPulse * 0.3);
        glowMat.opacity = 0.25 + stormPulse * 0.15;
        // Random white flashes
        if (Math.random() > 0.95) {
          ballMat.emissiveIntensity = 1.2;
          ballMat.emissive.setRGB(1, 1, 1);
        }
      }
    }

    // Randomize ball size and update visuals
    function randomizeBallSize() {
      currentBallRadius = BALL_MIN_RADIUS + Math.random() * (BALL_MAX_RADIUS - BALL_MIN_RADIUS);
      ball.scale.setScalar(currentBallRadius);
    }

    // Ball shadow blob on floor
    const shadowBlobGeo = new THREE.PlaneGeometry(1.2, 1.2);
    const shadowBlobMat = new THREE.MeshBasicMaterial({
      color: 0x000000,
      transparent: true,
      opacity: 0.3,
      depthWrite: false,
    });
    const shadowBlob = new THREE.Mesh(shadowBlobGeo, shadowBlobMat);
    shadowBlob.rotation.x = -Math.PI / 2;
    shadowBlob.position.y = 0.01;
    scene.add(shadowBlob);

    // ── Ball Trail Particles ────────────────────────────────────
    const TRAIL_COUNT = 20;
    const trailParticles = [];
    const trailGeo = new THREE.SphereGeometry(0.06, 6, 6);
    for (let i = 0; i < TRAIL_COUNT; i++) {
      const mat = new THREE.MeshBasicMaterial({ color: 0xff5252, transparent: true, opacity: 0, depthWrite: false });
      const mesh = new THREE.Mesh(trailGeo, mat);
      mesh.visible = false;
      scene.add(mesh);
      trailParticles.push({ mesh, mat, life: 0, maxLife: 0.4 });
    }
    let trailIdx = 0;
    let trailTimer = 0;

    function spawnTrailParticle(pos, color) {
      const p = trailParticles[trailIdx];
      trailIdx = (trailIdx + 1) % TRAIL_COUNT;
      p.mesh.position.copy(pos);
      p.mesh.visible = true;
      p.mat.color.set(color || 0xff5252);
      p.mat.opacity = 0.5;
      p.life = 0;
      const s = currentBallRadius * 0.5;
      p.mesh.scale.setScalar(s);
    }

    function updateTrail(dt) {
      for (const p of trailParticles) {
        if (!p.mesh.visible) continue;
        p.life += dt;
        const t = p.life / p.maxLife;
        if (t >= 1) { p.mesh.visible = false; continue; }
        p.mat.opacity = 0.4 * (1 - t);
        p.mesh.scale.multiplyScalar(0.96);
      }
    }

    // ── Ball Physics ────────────────────────────────────────────
    const ballPos = new THREE.Vector3(0, ROOM.h / 2, 0);
    const ballVel = new THREE.Vector3(
      (Math.random() - 0.5) * 6,
      (Math.random() - 0.5) * 4,
      (Math.random() - 0.5) * 6
    );
    const gravity = -10;
    const restitution = 0.82;
    const airDrag = 0.995;
    const minBounceVel = 1.5;

    // ── Element Explosion Textures (1024x1024 HD canvas-drawn shapes) ──
    const TEX_SIZE = 1024;
    const TEX_HALF = TEX_SIZE / 2;

    function makeExplosionTexture(drawFn) {
      const c = document.createElement('canvas');
      c.width = c.height = TEX_SIZE;
      const ctx = c.getContext('2d');
      drawFn(ctx, TEX_SIZE, TEX_HALF);
      return new THREE.CanvasTexture(c);
    }

    // Helper: draw spirals + scattered particles + bright center (wind-style base)
    function drawSpiralExplosion(ctx, S, H, opts) {
      // Background glow
      const bg = ctx.createRadialGradient(H, H, 0, H, H, H);
      bg.addColorStop(0, opts.glowInner);
      bg.addColorStop(0.5, opts.glowMid);
      bg.addColorStop(1, opts.glowOuter);
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, S, S);
      // Spirals
      const spiralCount = opts.spirals || 5;
      const turns = opts.turns || 5;
      for (let s = 0; s < spiralCount; s++) {
        const off = (s / spiralCount) * Math.PI * 2;
        ctx.beginPath();
        for (let t = 0; t < 300; t++) {
          const frac = t / 300;
          const angle = off + frac * Math.PI * turns;
          const r = frac * H * 0.92;
          const x = H + Math.cos(angle) * r;
          const y = H + Math.sin(angle) * r;
          if (t === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        const alpha = 0.8 + s * 0.04;
        ctx.strokeStyle = opts.spiralColor(s, alpha);
        ctx.lineWidth = opts.lineWidth || (10 - s * 1.5);
        ctx.shadowColor = opts.shadowColor;
        ctx.shadowBlur = opts.shadowBlur || 20;
        ctx.stroke();
      }
      // Scattered particles
      const pCount = opts.particles || 50;
      for (let i = 0; i < pCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * H * 0.85;
        const px = H + Math.cos(angle) * dist;
        const py = H + Math.sin(angle) * dist;
        const sz = 4 + Math.random() * 10;
        const pg = ctx.createRadialGradient(px, py, 0, px, py, sz);
        pg.addColorStop(0, opts.particleBright);
        pg.addColorStop(1, opts.particleFade);
        ctx.fillStyle = pg;
        ctx.fillRect(px - sz, py - sz, sz * 2, sz * 2);
      }
      // Bright center
      const cg = ctx.createRadialGradient(H, H, 0, H, H, H * 0.25);
      cg.addColorStop(0, 'rgba(255,255,255,1)');
      cg.addColorStop(0.4, opts.centerMid);
      cg.addColorStop(1, opts.centerOuter);
      ctx.fillStyle = cg;
      ctx.fillRect(0, 0, S, S);
    }

    // Default / Tier 1: cyan spirals with bright cyan particles
    const texDefault = makeExplosionTexture((ctx, S, H) => {
      drawSpiralExplosion(ctx, S, H, {
        glowInner: 'rgba(150,240,255,0.6)', glowMid: 'rgba(60,200,255,0.3)', glowOuter: 'rgba(20,120,220,0)',
        spirals: 4, turns: 4,
        spiralColor: (s, a) => `rgba(100,220,255,${a})`,
        lineWidth: 9, shadowColor: 'rgba(60,200,255,0.9)', shadowBlur: 22,
        particles: 45, particleBright: 'rgba(200,250,255,1)', particleFade: 'rgba(80,210,255,0)',
        centerMid: 'rgba(150,240,255,0.9)', centerOuter: 'rgba(60,200,255,0)',
      });
    });

    // Tier 2: rainbow spirals — each arm a different hue, bright particles
    const texSparkle = makeExplosionTexture((ctx, S, H) => {
      // Background rainbow glow
      const bg = ctx.createRadialGradient(H, H, 0, H, H, H);
      bg.addColorStop(0, 'rgba(255,255,255,0.5)');
      bg.addColorStop(0.4, 'rgba(255,200,255,0.3)');
      bg.addColorStop(1, 'rgba(200,100,255,0)');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, S, S);
      // Rainbow spirals
      const spiralCount = 6;
      for (let s = 0; s < spiralCount; s++) {
        const hue = (s / spiralCount) * 360;
        const off = (s / spiralCount) * Math.PI * 2;
        ctx.beginPath();
        for (let t = 0; t < 300; t++) {
          const frac = t / 300;
          const angle = off + frac * Math.PI * 5;
          const r = frac * H * 0.92;
          const x = H + Math.cos(angle) * r;
          const y = H + Math.sin(angle) * r;
          if (t === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = `hsla(${hue},100%,75%,0.9)`;
        ctx.lineWidth = 10;
        ctx.shadowColor = `hsla(${hue},100%,65%,1)`;
        ctx.shadowBlur = 25;
        ctx.stroke();
      }
      // Rainbow particles
      for (let i = 0; i < 60; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * H * 0.85;
        const px = H + Math.cos(angle) * dist;
        const py = H + Math.sin(angle) * dist;
        const sz = 4 + Math.random() * 10;
        const hue = Math.random() * 360;
        const pg = ctx.createRadialGradient(px, py, 0, px, py, sz);
        pg.addColorStop(0, `hsla(${hue},100%,90%,1)`);
        pg.addColorStop(1, `hsla(${hue},100%,70%,0)`);
        ctx.fillStyle = pg;
        ctx.fillRect(px - sz, py - sz, sz * 2, sz * 2);
      }
      // White center
      const cg = ctx.createRadialGradient(H, H, 0, H, H, H * 0.25);
      cg.addColorStop(0, 'rgba(255,255,255,1)');
      cg.addColorStop(0.5, 'rgba(255,255,255,0.9)');
      cg.addColorStop(1, 'rgba(255,220,255,0)');
      ctx.fillStyle = cg;
      ctx.fillRect(0, 0, S, S);
    });

    // Tier 3: fire spirals — orange/yellow/red swirls with hot particles
    const texFire = makeExplosionTexture((ctx, S, H) => {
      drawSpiralExplosion(ctx, S, H, {
        glowInner: 'rgba(255,220,100,0.7)', glowMid: 'rgba(255,100,0,0.4)', glowOuter: 'rgba(180,0,0,0)',
        spirals: 5, turns: 4.5,
        spiralColor: (s, a) => {
          const colors = ['rgba(255,255,150,','rgba(255,200,50,','rgba(255,140,20,','rgba(255,80,0,','rgba(255,50,0,'];
          return colors[s % colors.length] + a + ')';
        },
        lineWidth: 11, shadowColor: 'rgba(255,160,0,1)', shadowBlur: 28,
        particles: 55, particleBright: 'rgba(255,255,180,1)', particleFade: 'rgba(255,120,0,0)',
        centerMid: 'rgba(255,255,200,1)', centerOuter: 'rgba(255,150,30,0)',
      });
    });

    // Tier 4: ice spirals — icy blue/white crystalline swirls
    const texIce = makeExplosionTexture((ctx, S, H) => {
      drawSpiralExplosion(ctx, S, H, {
        glowInner: 'rgba(200,245,255,0.6)', glowMid: 'rgba(100,210,255,0.3)', glowOuter: 'rgba(50,140,255,0)',
        spirals: 5, turns: 5,
        spiralColor: (s, a) => {
          const colors = ['rgba(220,250,255,','rgba(180,235,255,','rgba(140,215,255,','rgba(100,200,255,','rgba(170,230,255,'];
          return colors[s % colors.length] + a + ')';
        },
        lineWidth: 9, shadowColor: 'rgba(120,210,255,1)', shadowBlur: 24,
        particles: 50, particleBright: 'rgba(240,255,255,1)', particleFade: 'rgba(100,200,255,0)',
        centerMid: 'rgba(220,250,255,1)', centerOuter: 'rgba(130,210,255,0)',
      });
    });

    // Tier 5: electric spirals — bright blue/white jagged swirls with sparks
    const texElectric = makeExplosionTexture((ctx, S, H) => {
      // Aura
      const bg = ctx.createRadialGradient(H, H, 0, H, H, H);
      bg.addColorStop(0, 'rgba(200,220,255,0.6)');
      bg.addColorStop(0.4, 'rgba(100,140,255,0.3)');
      bg.addColorStop(1, 'rgba(40,60,220,0)');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, S, S);
      // Jagged spirals (spiral path with jitter for lightning look)
      const spiralCount = 6;
      for (let s = 0; s < spiralCount; s++) {
        const off = (s / spiralCount) * Math.PI * 2;
        // Thick glow pass then bright core pass
        for (let pass = 0; pass < 2; pass++) {
          ctx.beginPath();
          for (let t = 0; t < 300; t++) {
            const frac = t / 300;
            const angle = off + frac * Math.PI * 5;
            const r = frac * H * 0.92;
            const jitter = (Math.random() - 0.5) * 18 * frac;
            const x = H + Math.cos(angle) * r + jitter;
            const y = H + Math.sin(angle) * r + jitter;
            if (t === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          if (pass === 0) {
            ctx.strokeStyle = 'rgba(80,130,255,0.7)';
            ctx.lineWidth = 14;
            ctx.shadowColor = 'rgba(100,160,255,1)';
            ctx.shadowBlur = 30;
          } else {
            ctx.strokeStyle = 'rgba(230,240,255,1)';
            ctx.lineWidth = 5;
            ctx.shadowColor = 'rgba(200,220,255,1)';
            ctx.shadowBlur = 15;
          }
          ctx.stroke();
        }
      }
      // Bright spark particles
      for (let i = 0; i < 55; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * H * 0.85;
        const px = H + Math.cos(angle) * dist;
        const py = H + Math.sin(angle) * dist;
        const sz = 3 + Math.random() * 9;
        const pg = ctx.createRadialGradient(px, py, 0, px, py, sz);
        pg.addColorStop(0, 'rgba(230,240,255,1)');
        pg.addColorStop(1, 'rgba(100,150,255,0)');
        ctx.fillStyle = pg;
        ctx.fillRect(px - sz, py - sz, sz * 2, sz * 2);
      }
      // White center
      const cg = ctx.createRadialGradient(H, H, 0, H, H, H * 0.25);
      cg.addColorStop(0, 'rgba(255,255,255,1)');
      cg.addColorStop(0.4, 'rgba(210,225,255,0.9)');
      cg.addColorStop(1, 'rgba(100,140,255,0)');
      ctx.fillStyle = cg;
      ctx.fillRect(0, 0, S, S);
    });

    // Tier 6: wind — bright green spirals with glowing particle trails
    const texWind = makeExplosionTexture((ctx, S, H) => {
      drawSpiralExplosion(ctx, S, H, {
        glowInner: 'rgba(120,255,200,0.6)', glowMid: 'rgba(60,220,140,0.3)', glowOuter: 'rgba(20,150,80,0)',
        spirals: 5, turns: 5,
        spiralColor: (s, a) => {
          const colors = ['rgba(140,255,200,','rgba(100,255,180,','rgba(80,255,160,','rgba(120,255,190,','rgba(160,255,210,'];
          return colors[s % colors.length] + a + ')';
        },
        lineWidth: 10, shadowColor: 'rgba(80,255,160,1)', shadowBlur: 24,
        particles: 55, particleBright: 'rgba(200,255,230,1)', particleFade: 'rgba(80,255,150,0)',
        centerMid: 'rgba(160,255,210,0.9)', centerOuter: 'rgba(80,230,140,0)',
      });
    });

    // Tier 7: storm — massive multi-color spirals, all elements interleaved
    const texStorm = makeExplosionTexture((ctx, S, H) => {
      // Intense background glow
      const bg = ctx.createRadialGradient(H, H, 0, H, H, H);
      bg.addColorStop(0, 'rgba(255,255,255,0.7)');
      bg.addColorStop(0.3, 'rgba(220,200,255,0.5)');
      bg.addColorStop(0.6, 'rgba(120,120,255,0.25)');
      bg.addColorStop(1, 'rgba(50,50,180,0)');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, S, S);
      // Interleaved element-colored spirals (fire, ice, electric, wind)
      const stormColors = [
        { stroke: 'rgba(255,220,80,0.9)', shadow: 'rgba(255,160,0,1)' },    // fire
        { stroke: 'rgba(180,240,255,0.9)', shadow: 'rgba(100,210,255,1)' },  // ice
        { stroke: 'rgba(200,210,255,0.9)', shadow: 'rgba(120,160,255,1)' },  // electric
        { stroke: 'rgba(130,255,190,0.9)', shadow: 'rgba(80,255,150,1)' },   // wind
        { stroke: 'rgba(255,180,255,0.9)', shadow: 'rgba(220,100,255,1)' },  // bonus purple
        { stroke: 'rgba(255,255,150,0.9)', shadow: 'rgba(255,255,50,1)' },   // bonus gold
      ];
      for (let s = 0; s < stormColors.length; s++) {
        const off = (s / stormColors.length) * Math.PI * 2;
        ctx.beginPath();
        for (let t = 0; t < 300; t++) {
          const frac = t / 300;
          const angle = off + frac * Math.PI * 6;
          const r = frac * H * 0.94;
          const jitter = (Math.random() - 0.5) * 8 * frac;
          const x = H + Math.cos(angle) * r + jitter;
          const y = H + Math.sin(angle) * r + jitter;
          if (t === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = stormColors[s].stroke;
        ctx.lineWidth = 12;
        ctx.shadowColor = stormColors[s].shadow;
        ctx.shadowBlur = 30;
        ctx.stroke();
      }
      // Multi-colored storm particles
      for (let i = 0; i < 80; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * H * 0.88;
        const px = H + Math.cos(angle) * dist;
        const py = H + Math.sin(angle) * dist;
        const sz = 5 + Math.random() * 12;
        const hue = Math.random() * 360;
        const pg = ctx.createRadialGradient(px, py, 0, px, py, sz);
        pg.addColorStop(0, `hsla(${hue},100%,90%,1)`);
        pg.addColorStop(1, `hsla(${hue},100%,70%,0)`);
        ctx.fillStyle = pg;
        ctx.fillRect(px - sz, py - sz, sz * 2, sz * 2);
      }
      // Huge white-hot center
      const cg = ctx.createRadialGradient(H, H, 0, H, H, H * 0.3);
      cg.addColorStop(0, 'rgba(255,255,255,1)');
      cg.addColorStop(0.3, 'rgba(255,255,255,0.95)');
      cg.addColorStop(0.6, 'rgba(220,210,255,0.6)');
      cg.addColorStop(1, 'rgba(150,140,255,0)');
      ctx.fillStyle = cg;
      ctx.fillRect(0, 0, S, S);
    });

    // Shockwave ring texture — expanding ring for layered explosions
    const texRing = makeExplosionTexture((ctx, S, H) => {
      ctx.lineWidth = 30;
      const rg = ctx.createRadialGradient(H, H, H * 0.45, H, H, H * 0.85);
      rg.addColorStop(0, 'rgba(255,255,255,0)');
      rg.addColorStop(0.3, 'rgba(255,255,255,0.9)');
      rg.addColorStop(0.5, 'rgba(200,220,255,1)');
      rg.addColorStop(0.7, 'rgba(255,255,255,0.9)');
      rg.addColorStop(1, 'rgba(200,200,255,0)');
      ctx.fillStyle = rg;
      ctx.fillRect(0, 0, S, S);
    });

    // Bright flash texture — pure white center burst
    const texFlash = makeExplosionTexture((ctx, S, H) => {
      const fg = ctx.createRadialGradient(H, H, 0, H, H, H * 0.6);
      fg.addColorStop(0, 'rgba(255,255,255,1)');
      fg.addColorStop(0.2, 'rgba(255,255,255,0.95)');
      fg.addColorStop(0.5, 'rgba(255,255,255,0.5)');
      fg.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = fg;
      ctx.fillRect(0, 0, S, S);
    });

    const explosionTextures = {
      default: texDefault, sparkle: texSparkle, fire: texFire,
      ice: texIce, electric: texElectric, wind: texWind, storm: texStorm,
      ring: texRing, flash: texFlash,
    };

    // ── Screen Flash Overlay ───────────────────────────────────
    const screenFlashEl = document.createElement('div');
    screenFlashEl.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;opacity:0;transition:opacity 0.05s;';
    document.body.appendChild(screenFlashEl);
    let screenFlashTimer = null;
    function screenFlash(color, intensity, duration) {
      screenFlashEl.style.background = color || 'white';
      screenFlashEl.style.opacity = intensity || 0.3;
      clearTimeout(screenFlashTimer);
      screenFlashTimer = setTimeout(() => {
        screenFlashEl.style.transition = `opacity ${duration || 0.3}s`;
        screenFlashEl.style.opacity = 0;
        setTimeout(() => { screenFlashEl.style.transition = 'opacity 0.05s'; }, (duration || 0.3) * 1000);
      }, 30);
    }

    // ── Camera Shake ──────────────────────────────────────────
    const cameraBasePos = camera.position.clone();
    let shakeIntensity = 0;
    let shakeDecay = 0;
    function triggerShake(intensity, decay) {
      shakeIntensity = intensity;
      shakeDecay = decay || 0.92;
    }

    // ── Explosion Sprite Pool (24 sprites for multi-layer) ─────
    const POOL_SIZE = 24;
    const explosionPool = [];
    const activeExplosions = [];

    for (let i = 0; i < POOL_SIZE; i++) {
      const mat = new THREE.SpriteMaterial({
        map: texDefault,
        transparent: true,
        opacity: 0,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });
      const sprite = new THREE.Sprite(mat);
      sprite.visible = false;
      scene.add(sprite);
      explosionPool.push({ sprite, mat, active: false });
    }

    function spawnExplosion(pos, tier, sizeMult, opts) {
      opts = opts || {};
      const tex = explosionTextures[tier] || texDefault;
      const maxScale = (sizeMult || 1) * 3;
      const duration = opts.duration || (tier === 'storm' ? 1.6 : tier === 'default' ? 0.7 : 1.0);
      // Find a free sprite
      let slot = explosionPool.find(s => !s.active);
      if (!slot) {
        const oldest = activeExplosions.shift();
        if (oldest) { oldest.active = false; oldest.sprite.visible = false; }
        slot = oldest || explosionPool[0];
      }
      slot.active = true;
      slot.mat.map = tex;
      slot.mat.opacity = 1;
      slot.mat.needsUpdate = true;
      slot.sprite.position.copy(pos);
      if (opts.offset) {
        slot.sprite.position.x += opts.offset.x || 0;
        slot.sprite.position.y += opts.offset.y || 0;
        slot.sprite.position.z += opts.offset.z || 0;
      }
      slot.sprite.scale.set(0.1, 0.1, 0.1);
      slot.sprite.visible = true;
      slot.sprite.material.rotation = Math.random() * Math.PI * 2;
      slot.sprite.renderOrder = opts.renderOrder || 0;
      activeExplosions.push({
        ...slot,
        age: opts.delay ? -opts.delay : 0,
        duration,
        maxScale,
        rotSpeed: opts.rotSpeed || 0.5,
      });
    }

    function streakExplosion(pos, streak) {
      const tier = getBallTierForStreak(streak);
      const p = pos.clone();

      if (streak >= 22) {
        // STORM: layered multi-element explosion
        spawnExplosion(p, 'flash', 1.5, { duration: 0.3, renderOrder: 3 });
        spawnExplosion(p, tier, 1.8, { renderOrder: 2 });
        spawnExplosion(p, 'ring', 2.0, { duration: 1.2, renderOrder: 1, rotSpeed: 0 });
        setTimeout(() => spawnExplosion(p, 'ring', 2.5, { duration: 1.4, renderOrder: 1, rotSpeed: 0 }), 100);
        screenFlash('rgba(255,255,255,0.5)', 0.35, 0.3);
        triggerShake(0.25, 0.92);

      } else if (streak >= 17) {
        // WIND: swirling burst + ring
        spawnExplosion(p, tier, 1.5, { renderOrder: 2 });
        spawnExplosion(p, 'ring', 1.6, { duration: 1.0, renderOrder: 1, rotSpeed: 0 });
        screenFlash('rgba(100,255,170,0.3)', 0.2, 0.25);
        triggerShake(0.15, 0.93);

      } else if (streak >= 12) {
        // ELECTRIC: crackling burst + ring
        spawnExplosion(p, tier, 1.4, { renderOrder: 2 });
        spawnExplosion(p, 'ring', 1.4, { duration: 0.9, renderOrder: 1, rotSpeed: 0 });
        screenFlash('rgba(120,150,255,0.3)', 0.18, 0.2);
        triggerShake(0.1, 0.94);

      } else if (streak >= 8) {
        // ICE: crystal burst
        spawnExplosion(p, tier, 1.3, { renderOrder: 2 });
        screenFlash('rgba(150,220,255,0.2)', 0.12, 0.15);
        triggerShake(0.06, 0.95);

      } else if (streak >= 5) {
        // FIRE: fiery burst
        spawnExplosion(p, tier, 1.2, { renderOrder: 2 });
        screenFlash('rgba(255,150,50,0.2)', 0.1, 0.15);

      } else if (streak >= 3) {
        // SPARKLE: colorful burst
        spawnExplosion(p, tier, 1.0, { renderOrder: 2 });

      } else {
        // DEFAULT: clean simple burst
        spawnExplosion(p, tier, 0.8, { renderOrder: 2 });
      }
    }

    // ── Raycaster for Mouse Interaction ─────────────────────────
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ── Score Pop Text (CSS) ────────────────────────────────────
    const messageEl = document.getElementById('message');
    function showMessage(text, color) {
      messageEl.textContent = text;
      messageEl.style.color = color || '#fff';
      messageEl.style.opacity = 1;
      setTimeout(() => { messageEl.style.opacity = 0; }, 800);
    }

    // ── Click Handler ───────────────────────────────────────────
    renderer.domElement.addEventListener('click', (e) => {
      if (!state.running || catchAnimActive) return;

      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(ball);

      // Forgiving hitbox: if ray passes close to ball center, count as hit
      let nearHit = false;
      if (hits.length === 0) {
        const ray = raycaster.ray;
        const closest = new THREE.Vector3();
        ray.closestPointToPoint(ball.position, closest);
        const dist = closest.distanceTo(ball.position);
        const forgiveness = currentBallRadius * 1.5; // 50% larger effective hitbox
        if (dist < forgiveness) nearHit = true;
      }

      if (hits.length > 0 || nearHit) {
        catchBall();
      } else {
        // Miss
        state.streak = 0;
        state.missStreak++;
        sessionMisses++;
        applyBallTier('default');
        sndMiss();
        stopCombo();

        // Mercy mechanic: grow ball every 3 consecutive misses
        if (state.missStreak % 3 === 0 && currentBallRadius < BALL_MAX_RADIUS) {
          currentBallRadius = Math.min(currentBallRadius + MERCY_GROW_STEP, BALL_MAX_RADIUS);
          ball.scale.setScalar(currentBallRadius);
          ball.geometry.computeBoundingSphere();
          showMessage('MERCY +SIZE', '#ff8a65');
        }

        updateHUD();
      }
    });

    // ── Ball Catch Animation System ─────────────────────────
    let catchAnimActive = false;
    let catchAnimTime = 0;
    let catchAnimDuration = 0.3;
    let catchAnimTier = 'default';
    let catchAnimBaseScale = 1;

    let catchRespawnPending = false;

    function playCatchAnim(tier) {
      catchAnimActive = true;
      catchAnimTime = 0;
      catchAnimTier = tier;
      catchAnimBaseScale = currentBallRadius;
      catchAnimDuration = 0.25;
      // Hide shadow during animation
      shadowBlob.visible = false;
    }

    function updateCatchAnim(dt) {
      if (!catchAnimActive) return;
      catchAnimTime += dt;
      const t = Math.min(catchAnimTime / catchAnimDuration, 1);
      const tier = catchAnimTier;
      const bs = catchAnimBaseScale;

      if (tier === 'fire') {
        // Rapid expand then shrink — ball inflates like it's about to burst then pops
        const s = t < 0.35 ? 1 + (t / 0.35) * 1.2 : 2.2 * Math.pow(1 - (t - 0.35) / 0.65, 2);
        ball.scale.setScalar(bs * Math.max(s, 0.01));
        // Squash/stretch — wider then taller
        const squash = t < 0.35 ? 1 + t * 0.8 : 1;
        ball.scale.x *= squash;
        ball.scale.y *= (2 - squash);
        ballMat.emissive.setRGB(1, 0.5 * (1 - t), 0);
        ballMat.emissiveIntensity = 3.0 * (1 - t * 0.7);
        // Slight upward drift as it "explodes"
        ball.position.y += dt * 2 * (1 - t);
      } else if (tier === 'ice') {
        // Freeze solid, crack, then shatter into nothing
        const wobble = Math.sin(t * 40) * Math.pow(1 - t, 2) * 0.4;
        const freeze = t < 0.3 ? 1 + t * 0.3 : (1.09) * (1 - Math.pow((t - 0.3) / 0.7, 0.5));
        ball.scale.setScalar(bs * Math.max(freeze + wobble, 0.01));
        // Color shift: normal -> icy blue -> white shatter
        const iceBlue = Math.min(t * 3, 1);
        ballMat.emissive.setRGB(0.3 * iceBlue, 0.6 * iceBlue, 1 * iceBlue);
        ballMat.emissiveIntensity = 2.0 * (t < 0.5 ? 1 : 1 - (t - 0.5) * 2);
        ballMat.opacity = t > 0.7 ? 1 - (t - 0.7) / 0.3 : 1;
        glowMat.opacity = ballMat.opacity * 0.22;
      } else if (tier === 'electric') {
        // Violent jittering with bright flashes, then zap away
        const jitter = Math.pow(1 - t, 1.5) * 0.6;
        ball.position.x = ballPos.x + (Math.random() - 0.5) * jitter;
        ball.position.y = ballPos.y + (Math.random() - 0.5) * jitter;
        ball.position.z = ballPos.z + (Math.random() - 0.5) * jitter;
        // Pulsing scale like electric surges
        const pulse = 1 + Math.sin(t * 50) * 0.15 * (1 - t);
        ball.scale.setScalar(bs * Math.max(pulse * (1 - t * 0.8), 0.01));
        // Flickering bright white/blue
        const flicker = Math.random();
        ballMat.emissive.setRGB(0.4 + flicker * 0.6, 0.5 + flicker * 0.5, 1);
        ballMat.emissiveIntensity = (flicker > 0.3 ? 3.0 : 0.5) * (1 - t * 0.5);
      } else if (tier === 'wind') {
        // Spin wildly, stretch into vortex shape, then vanish
        ball.rotation.y += dt * 60 * (1 - t * 0.5);
        ball.rotation.x += dt * 35 * (1 - t * 0.5);
        // Stretch vertically as it spins (tornado shape)
        const stretch = 1 + t * 1.5;
        const shrink = Math.max(1 - t, 0.01);
        ball.scale.set(bs * shrink, bs * shrink * stretch, bs * shrink);
        ballMat.emissive.setRGB(0.2, 1 * (1 - t * 0.3), 0.5);
        ballMat.emissiveIntensity = 2.0 * (1 - t * 0.5);
        // Spiral upward
        ball.position.y += dt * 3 * (1 - t);
      } else if (tier === 'storm') {
        // The ultimate: jitter + spin + scale pulse + rainbow + dramatic pop
        const jitter = Math.pow(1 - t, 1.5) * 0.7;
        ball.position.x = ballPos.x + (Math.random() - 0.5) * jitter;
        ball.position.y = ballPos.y + (Math.random() - 0.5) * jitter + dt * 4 * (1 - t);
        ball.position.z = ballPos.z + (Math.random() - 0.5) * jitter;
        ball.rotation.y += dt * 70 * (1 - t);
        ball.rotation.x += dt * 40 * (1 - t);
        // Dramatic expand then implode
        const s = t < 0.25 ? 1 + (t / 0.25) * 1.5 : 2.5 * Math.pow(1 - (t - 0.25) / 0.75, 1.5);
        ball.scale.setScalar(bs * Math.max(s, 0.01));
        // Rainbow cycling emissive
        const hue = (t * 6) % 1;
        ballMat.emissive.setHSL(hue, 1, 0.7);
        ballMat.emissiveIntensity = 4.0 * (1 - t * 0.5);
      } else if (tier === 'sparkle') {
        // Rainbow color cycle + bouncy squish
        const bounce = 1 + Math.sin(t * Math.PI * 4) * 0.25 * (1 - t);
        ball.scale.setScalar(bs * bounce * (1 - t * 0.4));
        const hue = (t * 4) % 1;
        ballMat.emissive.setHSL(hue, 1, 0.6);
        ballMat.emissiveIntensity = 2.5 * (1 - t * 0.5);
      } else {
        // Default — squish down then pop up and fade
        const s = t < 0.3 ? 1 + (t / 0.3) * 0.5 : 1.5 * (1 - (t - 0.3) / 0.7);
        ball.scale.setScalar(bs * Math.max(s, 0.01));
        // Squash on press, stretch on release
        if (t < 0.3) {
          ball.scale.x *= (1 + t);
          ball.scale.y *= (1 - t * 0.5);
        }
        ballMat.emissiveIntensity = 1.5 * (1 - t);
      }

      if (t >= 1) {
        catchAnimActive = false;
        // Respawn ball cleanly when animation ends
        if (catchRespawnPending) {
          catchRespawnPending = false;
          // Force re-apply tier (catch anims dirty the material)
          currentBallTier = '';
          applyBallTier(getBallTierForStreak(state.streak));
          ballMat.opacity = 1;
          ballMat.emissiveIntensity = 0.15;
          glowMat.opacity = BALL_TIERS[currentBallTier].glowOpacity;
          ball.rotation.set(0, 0, 0);
          randomizeBallSize();
          ballSpawnTime = clock.elapsedTime;
          ballPos.set(
            (Math.random() - 0.5) * (ROOM.w - 2),
            ROOM.h * 0.4 + Math.random() * 2,
            (Math.random() - 0.3) * (ROOM.d - 2)
          );
          ballVel.set(
            (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 4 + 2,
            (Math.random() - 0.5) * 5
          );
          ball.position.copy(ballPos);
          ball.scale.setScalar(currentBallRadius);
          shadowBlob.visible = true;
        }
      }
    }

    function catchBall() {
      state.streak++;
      state.missStreak = 0;
      const streakMult = state.streak;

      // Size multiplier: smaller ball = higher score (linear)
      const normalizedSize = (currentBallRadius - BALL_MIN_RADIUS) / (BALL_MAX_RADIUS - BALL_MIN_RADIUS);
      const sizeMult = 1 + SIZE_COEFF * (1 - normalizedSize);

      // Time multiplier: longer time = lower score (linear)
      const elapsed = clock.elapsedTime - ballSpawnTime;
      const timeMult = Math.max(TIME_MIN_MULT, 1 - TIME_COEFF * elapsed);

      const vipMult = isVIP() ? 2 : 1;
      const points = Math.round(10 * streakMult * sizeMult * timeMult * vipMult);
      state.score += points;
      if (state.streak > state.bestStreak) state.bestStreak = state.streak;

      updateHUD();

      // Feedback — show breakdown
      const sizeLabel = sizeMult >= 3 ? 'TINY' : sizeMult >= 2 ? 'SMALL' : 'BIG';
      const timeLabel = timeMult >= 0.7 ? 'FAST' : timeMult >= 0.4 ? '' : 'SLOW';
      let msg = `+${points}`;
      if (streakMult >= 5) msg += ` x${streakMult}`;
      if (sizeMult >= 2) msg += ` ${sizeLabel}!`;
      if (timeLabel === 'FAST') msg += ' QUICK!';
      // Element-themed message colors matching streak tier
      let msgColor;
      if (state.streak >= 22) { msgColor = '#ffffff'; }       // Storm — white
      else if (state.streak >= 17) { msgColor = '#7affa0'; }  // Wind — green
      else if (state.streak >= 12) { msgColor = '#82b1ff'; }  // Electric — blue
      else if (state.streak >= 8)  { msgColor = '#80deea'; }  // Ice — cyan
      else if (state.streak >= 5)  { msgColor = '#ff8a65'; }  // Fire — orange
      else if (sizeMult >= 3) { msgColor = '#ff9800'; }
      else { msgColor = '#4fc3f7'; }
      showMessage(msg, msgColor);

      // Sound
      sndCatch(state.streak);

      // Combo timer — reset on catch
      startCombo();

      // Floating score popup at ball screen position
      const ballScreenPos = ballPos.clone().project(camera);
      const sx = (ballScreenPos.x * 0.5 + 0.5) * innerWidth;
      const sy = (-ballScreenPos.y * 0.5 + 0.5) * innerHeight;
      spawnFloatScore(sx, sy, msg, msgColor);

      // Session counters + live achievement check
      sessionCatches++;
      {
        const liveStats = loadStats();
        liveStats.totalCatches++;
        if (state.bestStreak > liveStats.bestEverStreak) liveStats.bestEverStreak = state.bestStreak;
        if (state.score > liveStats.bestEverScore) liveStats.bestEverScore = state.score;
        saveStats(liveStats);
        checkAchievements(liveStats);
      }

      // Trigger catch animation using the CURRENT tier (before streak increment changes it)
      const currentTier = getBallTierForStreak(state.streak);
      playCatchAnim(currentTier);
      catchRespawnPending = true;

      // Particles — streak-based explosions
      streakExplosion(ballPos.clone(), state.streak);
    }

    // ── HUD Update ──────────────────────────────────────────────
    function updateHUD() {
      document.getElementById('score-value').textContent = state.score;
      document.getElementById('streak-value').textContent = state.streak;
    }

    function updateTimerHUD() {
      state.sessionTime = clock.elapsedTime - state.sessionStart;
      document.getElementById('time-value').textContent = formatTime(state.sessionTime);
    }

    // Live bonus display updated every frame
    function updateBonusHUD() {
      const bonusEl = document.getElementById('bonus-value');
      if (catchAnimActive) {
        bonusEl.textContent = '--';
        bonusEl.classList.remove('low');
        return;
      }
      const normalizedSize = (currentBallRadius - BALL_MIN_RADIUS) / (BALL_MAX_RADIUS - BALL_MIN_RADIUS);
      const sizeMult = 1 + SIZE_COEFF * (1 - normalizedSize);
      const elapsed = clock.elapsedTime - ballSpawnTime;
      const timeMult = Math.max(TIME_MIN_MULT, 1 - TIME_COEFF * elapsed);
      const totalBonus = sizeMult * timeMult;
      bonusEl.textContent = `x${totalBonus.toFixed(1)}`;
      bonusEl.classList.toggle('low', timeMult < 0.4);
    }

    // ── Resize Handler ──────────────────────────────────────────
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ── Screen Helpers ──────────────────────────────────────────
    function showScreen(id) {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('name-screen').style.display = 'none';
      document.getElementById('leaderboard').style.display = 'none';
      document.getElementById('stats-screen').style.display = 'none';
      document.getElementById('end-btn').style.display = 'none';
      if (id) {
        const el = document.getElementById(id);
        el.style.display = el.classList.contains('overlay') ? 'flex' : '';
      }
    }

    function startGame() {
      // Capture and persist player name
      const name = nameInput.value.trim() || 'Anonymous';
      state.playerName = name;
      localStorage.setItem(NAME_KEY, name);

      showScreen(null);
      document.getElementById('end-btn').style.display = '';
      state.running = true;
      state.score = 0;
      state.streak = 0;
      state.bestStreak = 0;
      state.missStreak = 0;
      state.sessionStart = clock.elapsedTime;
      state.sessionTime = 0;
      state.sessionStartWall = Date.now();

      // Reset catch animation state from any previous session
      catchAnimActive = false;
      catchRespawnPending = false;
      ballMat.opacity = 1;
      glowMat.opacity = 0.12;
      ball.rotation.set(0, 0, 0);

      randomizeBallSize();
      ballSpawnTime = clock.elapsedTime;
      // Force re-apply even if already 'default' (catch anims dirty the material)
      currentBallTier = '';
      applyBallTier('default');
      ballPos.set(0, ROOM.h / 2, 0);
      ball.position.copy(ballPos);
      ball.scale.setScalar(currentBallRadius);
      ballVel.set(
        (Math.random() - 0.5) * 6,
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 6
      );
      shadowBlob.visible = true;
      updateHUD();
      document.getElementById('time-value').textContent = '0:00';
      document.getElementById('bonus-value').textContent = '--';

      // Reset new systems
      sessionCatches = 0;
      sessionMisses = 0;
      stopCombo();
      muteBtn.style.display = '';

      // Start live session persistence
      saveLiveSession();
    }

    function endSession() {
      if (!state.running) return;
      state.running = false;
      state.sessionTime = clock.elapsedTime - state.sessionStart;
      clearLiveSession();
      stopCombo();
      muteBtn.style.display = 'none';

      // Update all-time stats
      const stats = loadStats();
      stats.totalGames++;
      stats.totalCatches += sessionCatches;
      stats.totalMisses += sessionMisses;
      stats.totalScore += state.score;
      stats.totalTime += state.sessionTime;
      if (state.score > stats.bestEverScore) stats.bestEverScore = state.score;
      if (state.bestStreak > stats.bestEverStreak) stats.bestEverStreak = state.bestStreak;
      if (state.sessionTime > stats.longestSession) stats.longestSession = state.sessionTime;
      saveStats(stats);
      checkAchievements(stats);

      const newFlags = recordSession(state.playerName, state.score, state.bestStreak, state.sessionTime);
      renderLeaderboard(newFlags, state.score, state.bestStreak, state.sessionTime);
      showScreen('leaderboard');
    }

    // ── Button Wiring ────────────────────────────────────────────
    const nameError = document.getElementById('name-error');

    function showNameScreen() {
      nameInput.value = localStorage.getItem(NAME_KEY) || '';
      nameError.textContent = '';
      showScreen('name-screen');
      nameInput.focus();
    }

    // ── Name Registry (no duplicates) ───────────────────────
    const NAMES_KEY = 'bouncingBall_registeredNames';
    function loadRegisteredNames() {
      try { return JSON.parse(localStorage.getItem(NAMES_KEY)) || {}; } catch { return {}; }
    }
    function registerName(name) {
      const reg = loadRegisteredNames();
      reg[name.toLowerCase()] = name;
      localStorage.setItem(NAMES_KEY, JSON.stringify(reg));
    }
    function isNameTaken(name, currentSaved) {
      const reg = loadRegisteredNames();
      const lower = name.toLowerCase();
      // Allow if it's the player's own saved name
      if (currentSaved && currentSaved.toLowerCase() === lower) return false;
      return !!reg[lower];
    }

    function tryStartFromName() {
      const name = nameInput.value.trim();
      if (!name) {
        nameError.textContent = 'Please enter a name to play.';
        nameInput.focus();
        return;
      }
      const savedName = localStorage.getItem(NAME_KEY);
      if (isNameTaken(name, savedName)) {
        nameError.textContent = 'That name is already taken. Try another!';
        nameInput.focus();
        return;
      }
      nameError.textContent = '';
      registerName(name);
      startGame();
    }

    document.getElementById('start-btn').addEventListener('click', showNameScreen);
    document.getElementById('start-lb-btn').addEventListener('click', () => {
      renderLeaderboard(null, null, null, null);
      showScreen('leaderboard');
    });
    document.getElementById('name-go-btn').addEventListener('click', tryStartFromName);
    document.getElementById('name-cancel-btn').addEventListener('click', () => showScreen('start-screen'));
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') tryStartFromName(); });
    document.getElementById('end-btn').addEventListener('click', endSession);
    document.getElementById('lb-play-btn').addEventListener('click', showNameScreen);
    document.getElementById('lb-back-btn').addEventListener('click', () => showScreen('start-screen'));
    document.getElementById('start-stats-btn').addEventListener('click', () => { renderStatsPage(); showScreen('stats-screen'); });
    document.getElementById('stats-back-btn').addEventListener('click', () => showScreen('start-screen'));
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && state.running) endSession(); });

    // ── Crash / Tab-close Recovery ───────────────────────────────
    // Save live session periodically (every 5s) and on every visibility change / tab close
    setInterval(saveLiveSession, 5000);
    window.addEventListener('beforeunload', saveLiveSession);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') saveLiveSession();
    });

    // ── Animation Loop ──────────────────────────────────────────
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      if (state.running) {
        // During catch animation, freeze physics and let the animation drive the ball
        if (!catchAnimActive) {
          // ── Ball Physics ──────────────────────────────
          ballVel.y += gravity * dt;
          ballVel.multiplyScalar(airDrag);

          ballPos.addScaledVector(ballVel, dt);

          // Bounce off walls
          const halfW = ROOM.w / 2 - currentBallRadius;
          const halfD = ROOM.d / 2 - currentBallRadius;

          if (ballPos.x < -halfW) { ballPos.x = -halfW; ballVel.x = Math.abs(ballVel.x) * restitution; }
          if (ballPos.x > halfW)  { ballPos.x = halfW;  ballVel.x = -Math.abs(ballVel.x) * restitution; }
          if (ballPos.z < -halfD) { ballPos.z = -halfD; ballVel.z = Math.abs(ballVel.z) * restitution; }
          if (ballPos.z > halfD)  { ballPos.z = halfD;  ballVel.z = -Math.abs(ballVel.z) * restitution; }

          // Floor bounce
          if (ballPos.y < currentBallRadius) {
            ballPos.y = currentBallRadius;
            ballVel.y = Math.abs(ballVel.y) * restitution;
            sndBounce(ballVel.length());
            // Ensure it keeps bouncing
            if (ballVel.y < minBounceVel) ballVel.y = minBounceVel + Math.random() * 2;
            // Add random horizontal kick to keep it interesting
            ballVel.x += (Math.random() - 0.5) * 1.2;
            ballVel.z += (Math.random() - 0.5) * 1.2;
          }

          // Ceiling bounce
          if (ballPos.y > ROOM.h - currentBallRadius) {
            ballPos.y = ROOM.h - currentBallRadius;
            ballVel.y = -Math.abs(ballVel.y) * restitution;
          }

          ball.position.copy(ballPos);

          // Shadow blob follows ball on floor
          shadowBlob.position.x = ballPos.x;
          shadowBlob.position.z = ballPos.z;
          const shadowScale = 1.0 - (ballPos.y / ROOM.h) * 0.5;
          shadowBlob.scale.set(shadowScale, shadowScale, 1);
          shadowBlobMat.opacity = 0.3 * (1.0 - ballPos.y / ROOM.h);

          // Ease emissive back
          ballMat.emissiveIntensity += (0.15 - ballMat.emissiveIntensity) * 3 * dt;

          // Ball rotation
          ball.rotation.x += ballVel.z * dt;
          ball.rotation.z -= ballVel.x * dt;

          // Animate ball tier visuals (color shifts, flashes, etc.)
          animateBallTier(clock.elapsedTime, dt);
        }

        // Ball catch animation (squish/pop per element) — runs independently of physics
        updateCatchAnim(dt);

        // ── Explosion Sprites ─────────────────────────
        for (let i = activeExplosions.length - 1; i >= 0; i--) {
          const e = activeExplosions[i];
          e.age += dt;
          // Support delayed spawns (negative age)
          if (e.age < 0) { e.sprite.visible = false; continue; }
          e.sprite.visible = true;
          const t = Math.min(e.age / e.duration, 1);
          // Fast expand with elastic overshoot for punch
          const easeOut = 1 - Math.pow(1 - t, 4);
          const overshoot = t < 0.15 ? 1 + Math.sin(t / 0.15 * Math.PI) * 0.15 : 1;
          const scale = e.maxScale * easeOut * overshoot;
          e.sprite.scale.set(scale, scale, scale);
          // Stay bright for 75%, then fade out smoothly
          const fadeStart = 0.75;
          e.mat.opacity = t < fadeStart ? 1.0 : 1.0 - Math.pow((t - fadeStart) / (1 - fadeStart), 0.7);
          // Rotation per sprite
          e.sprite.material.rotation += dt * (e.rotSpeed || 0.5);
          if (t >= 1) {
            e.active = false;
            e.sprite.visible = false;
            activeExplosions.splice(i, 1);
          }
        }

        // ── Camera Shake ──────────────────────────────
        if (shakeIntensity > 0.001) {
          camera.position.x = cameraBasePos.x + (Math.random() - 0.5) * shakeIntensity;
          camera.position.y = cameraBasePos.y + (Math.random() - 0.5) * shakeIntensity;
          shakeIntensity *= shakeDecay;
        } else {
          camera.position.x = cameraBasePos.x;
          camera.position.y = cameraBasePos.y;
        }

        // ── Combo Timer ─────────────────────────────────
        updateCombo(dt);

        // ── Ball Trail ─────────────────────────────────
        trailTimer += dt;
        if (trailTimer > 0.03 && !catchAnimActive) {
          trailTimer = 0;
          const trailColor = ballMat.color.getHex();
          spawnTrailParticle(ballPos, trailColor);
        }
        updateTrail(dt);

        // ── Live HUD updates ────────────────────────────
        updateTimerHUD();
        updateBonusHUD();

        // ── Accent light pulse ────────────────────────
        const t = clock.elapsedTime;
        accentLight1.intensity = 12 + Math.sin(t * 1.5) * 5;
        accentLight2.intensity = 12 + Math.cos(t * 1.8) * 5;
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>

  <!-- VIP Purchase Modal -->
  <div class="vip-overlay" id="vip-overlay">
    <div class="vip-modal" id="vip-modal">
      <div class="vip-modal-icon">&#x1F451;</div>
      <div class="vip-modal-title">VIP Pass</div>
      <div class="vip-modal-price">£0.99 <small>one-time</small></div>
      <ul class="vip-modal-perks">
        <li><span class="perk-icon">&#x2B50;</span> VIP star badge next to your name</li>
        <li><span class="perk-icon">&#x1F451;</span> Gold highlighted name on leaderboard</li>
        <li><span class="perk-icon">&#x1F525;</span> 2x score multiplier on all points</li>
      </ul>
      <button class="vip-confirm-btn" id="vip-confirm-btn">Purchase VIP — £0.99</button>
      <button class="vip-cancel-btn" id="vip-cancel-btn">No thanks</button>
    </div>
  </div>
</body>
</html>
