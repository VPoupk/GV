<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Bouncing Ball - Catch Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    canvas { display: block; cursor: crosshair; }

    #hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 10;
      pointer-events: none;
    }
    .hud-item {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 10px 20px;
      color: #fff;
      text-align: center;
    }
    .hud-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 2px;
    }
    .hud-value {
      font-size: 28px;
      font-weight: 700;
    }
    #score-value { color: #4fc3f7; }
    #streak-value { color: #ffb74d; }
    #best-value { color: #ce93d8; }

    #message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 22px;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      z-index: 10;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
      transition: opacity 0.3s;
    }

    #start-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      color: #fff;
    }
    #start-screen h1 {
      font-size: 48px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #4fc3f7, #ce93d8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    #start-screen p {
      font-size: 18px;
      color: rgba(255,255,255,0.6);
      margin-bottom: 30px;
    }
    #start-btn {
      padding: 14px 40px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 30px;
      background: linear-gradient(135deg, #4fc3f7, #7c4dff);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #start-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(79, 195, 247, 0.4);
    }
  </style>
</head>
<body>
  <div id="start-screen">
    <h1>Bouncing Ball</h1>
    <p>Click the bouncing ball to score points</p>
    <button id="start-btn">Play</button>
  </div>

  <div id="hud">
    <div class="hud-item">
      <div class="hud-label">Score</div>
      <div class="hud-value" id="score-value">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Streak</div>
      <div class="hud-value" id="streak-value">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Best</div>
      <div class="hud-value" id="best-value">0</div>
    </div>
  </div>

  <div id="message"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ── Game State ──────────────────────────────────────────────
    const state = {
      score: 0,
      streak: 0,
      best: 0,
      running: false,
    };

    // ── Room Dimensions ─────────────────────────────────────────
    const ROOM = { w: 10, h: 7, d: 10 };
    const BALL_RADIUS = 0.4;

    // ── Scene Setup ─────────────────────────────────────────────
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x1a1a2e, 0.035);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 2, ROOM.d / 2 + 4);
    camera.lookAt(0, 1, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // ── Lighting ────────────────────────────────────────────────
    const ambientLight = new THREE.AmbientLight(0x404060, 0.8);
    scene.add(ambientLight);

    const mainLight = new THREE.PointLight(0xffffff, 60, 30);
    mainLight.position.set(0, ROOM.h - 1, 0);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(1024, 1024);
    scene.add(mainLight);

    // Light fixture visual
    const bulbGeo = new THREE.SphereGeometry(0.2, 16, 16);
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
    const bulb = new THREE.Mesh(bulbGeo, bulbMat);
    bulb.position.copy(mainLight.position);
    scene.add(bulb);

    const accentLight1 = new THREE.PointLight(0x4fc3f7, 15, 15);
    accentLight1.position.set(-ROOM.w / 2 + 1, 1, -ROOM.d / 2 + 1);
    scene.add(accentLight1);

    const accentLight2 = new THREE.PointLight(0xce93d8, 15, 15);
    accentLight2.position.set(ROOM.w / 2 - 1, 1, ROOM.d / 2 - 1);
    scene.add(accentLight2);

    // ── Room Construction ───────────────────────────────────────
    const wallMat = new THREE.MeshStandardMaterial({
      color: 0x2c2c3e,
      roughness: 0.85,
      metalness: 0.05,
    });

    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x3a3a4e,
      roughness: 0.6,
      metalness: 0.1,
    });

    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Ceiling
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), wallMat);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = ROOM.h;
    scene.add(ceiling);

    // Back wall
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.h), wallMat);
    backWall.position.set(0, ROOM.h / 2, -ROOM.d / 2);
    backWall.receiveShadow = true;
    scene.add(backWall);

    // Front wall (transparent so we can see in)
    // Left wall
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.d, ROOM.h), wallMat);
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.set(-ROOM.w / 2, ROOM.h / 2, 0);
    leftWall.receiveShadow = true;
    scene.add(leftWall);

    // Right wall
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.d, ROOM.h), wallMat);
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.set(ROOM.w / 2, ROOM.h / 2, 0);
    rightWall.receiveShadow = true;
    scene.add(rightWall);

    // ── Decorative Edge Lines ───────────────────────────────────
    const edgeMat = new THREE.LineBasicMaterial({ color: 0x5a5a7a, transparent: true, opacity: 0.4 });
    function addEdge(points) {
      const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(...p)));
      scene.add(new THREE.Line(geo, edgeMat));
    }
    const hw = ROOM.w / 2, hd = ROOM.d / 2, h = ROOM.h;
    // Floor edges
    addEdge([[-hw, 0, -hd], [hw, 0, -hd]]);
    addEdge([[-hw, 0, -hd], [-hw, 0, hd]]);
    addEdge([[hw, 0, -hd], [hw, 0, hd]]);
    // Ceiling edges
    addEdge([[-hw, h, -hd], [hw, h, -hd]]);
    addEdge([[-hw, h, -hd], [-hw, h, hd]]);
    addEdge([[hw, h, -hd], [hw, h, hd]]);
    // Vertical edges
    addEdge([[-hw, 0, -hd], [-hw, h, -hd]]);
    addEdge([[hw, 0, -hd], [hw, h, -hd]]);

    // ── Ball ────────────────────────────────────────────────────
    const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
    const ballMat = new THREE.MeshStandardMaterial({
      color: 0xff5252,
      roughness: 0.2,
      metalness: 0.6,
      emissive: 0xff5252,
      emissiveIntensity: 0.15,
    });
    const ball = new THREE.Mesh(ballGeo, ballMat);
    ball.castShadow = true;
    scene.add(ball);

    // Ball glow
    const glowMat = new THREE.MeshBasicMaterial({
      color: 0xff5252,
      transparent: true,
      opacity: 0.12,
    });
    const glow = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS * 1.6, 16, 16), glowMat);
    ball.add(glow);

    // Ball shadow blob on floor
    const shadowBlobGeo = new THREE.PlaneGeometry(1.2, 1.2);
    const shadowBlobMat = new THREE.MeshBasicMaterial({
      color: 0x000000,
      transparent: true,
      opacity: 0.3,
      depthWrite: false,
    });
    const shadowBlob = new THREE.Mesh(shadowBlobGeo, shadowBlobMat);
    shadowBlob.rotation.x = -Math.PI / 2;
    shadowBlob.position.y = 0.01;
    scene.add(shadowBlob);

    // ── Ball Physics ────────────────────────────────────────────
    const ballPos = new THREE.Vector3(0, ROOM.h / 2, 0);
    const ballVel = new THREE.Vector3(
      (Math.random() - 0.5) * 6,
      (Math.random() - 0.5) * 4,
      (Math.random() - 0.5) * 6
    );
    const gravity = -12;
    const restitution = 0.85;
    const airDrag = 0.998;
    const minBounceVel = 2;

    // ── Particles ───────────────────────────────────────────────
    const MAX_PARTICLES = 200;
    const particlePositions = new Float32Array(MAX_PARTICLES * 3);
    const particleColors = new Float32Array(MAX_PARTICLES * 3);
    const particleGeo = new THREE.BufferGeometry();
    particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

    const particleMat = new THREE.PointsMaterial({
      size: 0.12,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      depthWrite: false,
    });
    const particleSystem = new THREE.Points(particleGeo, particleMat);
    scene.add(particleSystem);

    const particles = [];

    function spawnParticles(pos, color, count) {
      const c = new THREE.Color(color);
      for (let i = 0; i < count; i++) {
        particles.push({
          pos: pos.clone(),
          vel: new THREE.Vector3(
            (Math.random() - 0.5) * 8,
            Math.random() * 6 + 2,
            (Math.random() - 0.5) * 8
          ),
          color: c,
          life: 1.0,
          decay: 0.6 + Math.random() * 0.8,
        });
      }
      // Cap total
      while (particles.length > MAX_PARTICLES) particles.shift();
    }

    // ── Raycaster for Mouse Interaction ─────────────────────────
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ── Score Pop Text (CSS) ────────────────────────────────────
    const messageEl = document.getElementById('message');
    function showMessage(text, color) {
      messageEl.textContent = text;
      messageEl.style.color = color || '#fff';
      messageEl.style.opacity = 1;
      setTimeout(() => { messageEl.style.opacity = 0; }, 800);
    }

    // ── Click Handler ───────────────────────────────────────────
    renderer.domElement.addEventListener('click', (e) => {
      if (!state.running) return;

      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(ball);

      if (hits.length > 0) {
        catchBall();
      } else {
        // Miss
        state.streak = 0;
        updateHUD();
      }
    });

    function catchBall() {
      state.streak++;
      const multiplier = Math.min(state.streak, 10);
      const points = 10 * multiplier;
      state.score += points;
      if (state.score > state.best) state.best = state.score;

      updateHUD();

      // Feedback
      if (state.streak >= 5) {
        showMessage(`+${points}  x${multiplier} COMBO!`, '#ffb74d');
      } else {
        showMessage(`+${points}`, '#4fc3f7');
      }

      // Particles
      spawnParticles(ballPos, multiplier >= 5 ? 0xffb74d : 0x4fc3f7, 30 + state.streak * 5);

      // Flash ball
      ballMat.emissiveIntensity = 1.0;

      // Relaunch ball to random position with new velocity
      ballPos.set(
        (Math.random() - 0.5) * (ROOM.w - 2),
        ROOM.h * 0.5 + Math.random() * 2,
        (Math.random() - 0.5) * (ROOM.d - 2)
      );
      ballVel.set(
        (Math.random() - 0.5) * 8,
        (Math.random() - 0.5) * 5 + 3,
        (Math.random() - 0.5) * 8
      );
    }

    // ── HUD Update ──────────────────────────────────────────────
    function updateHUD() {
      document.getElementById('score-value').textContent = state.score;
      document.getElementById('streak-value').textContent = state.streak;
      document.getElementById('best-value').textContent = state.best;
    }

    // ── Resize Handler ──────────────────────────────────────────
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ── Start Button ────────────────────────────────────────────
    document.getElementById('start-btn').addEventListener('click', () => {
      document.getElementById('start-screen').style.display = 'none';
      state.running = true;
      state.score = 0;
      state.streak = 0;
      updateHUD();
    });

    // ── Animation Loop ──────────────────────────────────────────
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      if (state.running) {
        // ── Ball Physics ──────────────────────────────
        ballVel.y += gravity * dt;
        ballVel.multiplyScalar(airDrag);

        ballPos.addScaledVector(ballVel, dt);

        // Bounce off walls
        const halfW = ROOM.w / 2 - BALL_RADIUS;
        const halfD = ROOM.d / 2 - BALL_RADIUS;

        if (ballPos.x < -halfW) { ballPos.x = -halfW; ballVel.x = Math.abs(ballVel.x) * restitution; }
        if (ballPos.x > halfW)  { ballPos.x = halfW;  ballVel.x = -Math.abs(ballVel.x) * restitution; }
        if (ballPos.z < -halfD) { ballPos.z = -halfD; ballVel.z = Math.abs(ballVel.z) * restitution; }
        if (ballPos.z > halfD)  { ballPos.z = halfD;  ballVel.z = -Math.abs(ballVel.z) * restitution; }

        // Floor bounce
        if (ballPos.y < BALL_RADIUS) {
          ballPos.y = BALL_RADIUS;
          ballVel.y = Math.abs(ballVel.y) * restitution;
          // Ensure it keeps bouncing
          if (ballVel.y < minBounceVel) ballVel.y = minBounceVel + Math.random() * 3;
          // Add random horizontal kick to keep it interesting
          ballVel.x += (Math.random() - 0.5) * 2;
          ballVel.z += (Math.random() - 0.5) * 2;
        }

        // Ceiling bounce
        if (ballPos.y > ROOM.h - BALL_RADIUS) {
          ballPos.y = ROOM.h - BALL_RADIUS;
          ballVel.y = -Math.abs(ballVel.y) * restitution;
        }

        ball.position.copy(ballPos);

        // Shadow blob follows ball on floor
        shadowBlob.position.x = ballPos.x;
        shadowBlob.position.z = ballPos.z;
        const shadowScale = 1.0 - (ballPos.y / ROOM.h) * 0.5;
        shadowBlob.scale.set(shadowScale, shadowScale, 1);
        shadowBlobMat.opacity = 0.3 * (1.0 - ballPos.y / ROOM.h);

        // Ease emissive back
        ballMat.emissiveIntensity += (0.15 - ballMat.emissiveIntensity) * 3 * dt;

        // Ball rotation
        ball.rotation.x += ballVel.z * dt;
        ball.rotation.z -= ballVel.x * dt;

        // ── Particles ─────────────────────────────────
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.vel.y -= 10 * dt;
          p.pos.addScaledVector(p.vel, dt);
          p.life -= p.decay * dt;
          if (p.life <= 0) { particles.splice(i, 1); }
        }

        // Update particle buffers
        for (let i = 0; i < MAX_PARTICLES; i++) {
          if (i < particles.length) {
            const p = particles[i];
            particlePositions[i * 3] = p.pos.x;
            particlePositions[i * 3 + 1] = p.pos.y;
            particlePositions[i * 3 + 2] = p.pos.z;
            particleColors[i * 3] = p.color.r * p.life;
            particleColors[i * 3 + 1] = p.color.g * p.life;
            particleColors[i * 3 + 2] = p.color.b * p.life;
          } else {
            particlePositions[i * 3] = 0;
            particlePositions[i * 3 + 1] = -100;
            particlePositions[i * 3 + 2] = 0;
          }
        }
        particleGeo.attributes.position.needsUpdate = true;
        particleGeo.attributes.color.needsUpdate = true;

        // ── Accent light pulse ────────────────────────
        const t = clock.elapsedTime;
        accentLight1.intensity = 12 + Math.sin(t * 1.5) * 5;
        accentLight2.intensity = 12 + Math.cos(t * 1.8) * 5;
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
